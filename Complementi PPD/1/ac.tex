\documentclass{report}
\usepackage{graphicx} % Required for inserting images
\usepackage[italian]{babel}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{float}
\usepackage{soul}
\usepackage{listings} % Per evidenziare il codice

\definecolor{lightgray}{rgb}{0.9,0.9,0.9} % Definizione colore sfondo
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}

\lstset{
    backgroundcolor=\color{lightgray}, % Sfondo grigio
    basicstyle=\ttfamily, % Font monospaziato
    % frame=single, % Bordo attorno al codice
    tabsize=4, % Dimensione tabulazione
    breaklines=true, % Permette di andare a capo automaticamente
    numbers = left,
    numberstyle=\small\color{gray}
}

\title{\huge\textbf{{Controllo degli Accessi}}}
\date{Parte I}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Introduzione}

\noindent Il \textbf{controllo degli accessi} valuta l'accesso richiesto alle risorse dagli 
utenti autenticati e, sulla base di \textit{regole di accesso} (definite all'interno)
del sistema, determina se l'accesso sia garantito o negato.

Si occupa solamente dell'\textbf{accesso diretto}. Si basa su due concetti:
\begin{itemize}
    \item \textbf{Autenticazione/Identificazione} dell'utente che fa la richiesta
    \begin{itemize}
        \item importante anche per le problematiche di \textit{accountability}; posso
        analizzare i log per capire chi ha fatto che cosa nel caso ci sia un problema
    \end{itemize}
    \item \textbf{Correttezza delle autorizzazioni} con cui l'accesso viene valutato
\end{itemize}

\section{Politiche, modelli, meccanismi}
È utile fare una distinzione tra:
\begin{itemize}
    \item \textbf{Politiche:} sono i requisiti di protezione ad alto livello che voglio applicare 
    al mio sistema 
    \item \textbf{Model:} viene usato per rappresentare la politica 
    \item \textbf{Meccanismi:} implementano la politica con \textit{hw} e \textit{sw}
\end{itemize}

\noindent Risulta utile fare questa distinzione perché comporta dei vantaggi: posso 
verificare se il modello è corretto rispetto alla politica che ho definito; lo 
stesso meccanismo può essere usato per implementare politiche o modelli diversi.

\subsection{Meccanismo}
In letteratura prende il nome di \textit{reference monitor}, deve soddisfarre le 
seguenti proprietà:
\begin{itemize}
    \item non può essere modificabile; nel caso in cui venga fatto me ne devo accorgere 
    \item non può essere bypassabile 
    \item deve essere confinato ad una specifica parte del mio sistema (non distribuito)
    \item deve essere abbastanza piccolo per essere soggetto a processi di verifica formale
\end{itemize}

\noindent Il meccanismo deve essere sicuro rispetto ai canali di comunicazione non 
legittimi:
\begin{itemize}
    \item \textbf{Storage channels:} le parti di memoria, prima di essere rese disponibili 
    ad altri dati, dovrebbero essere \textit{pulite} (se cancello un dato non è che \textit{sparisce} dalla 
    memoria fisica dal computer \dots)
    \item \textbf{Covert channels:} canali non intesi per il trasferimento di informazioni
    che possono essere usati per inferire informazioni
\end{itemize}

\subsubsection{Alcuni principi di design}
\begin{itemize}
    \item \textit{Separazione dei privilegi:} non dare troppo \textit{potere} ad un solo utente 
    \item \textit{Privilegio minimo:} voglio darti il minimo privilegio di cui hai bisogno
\end{itemize}

\section{Processo di sviluppo di un AC}
Una volta definito il modello, posso verificare due aspetti:
\begin{itemize}
    \item \textbf{Completezza:} verificare che hai rappresentato tutti i requisiti di sicurezza della politica
    \item \textbf{Consistenza:} dev essere privo di contraddizioni (un utente ha sia accesso/negazione per una risorsa)
\end{itemize}






\chapter{Discretionary (DAC) policies: approcci base}

\noindent Sono politiche basate su:
\begin{itemize}
    \item \textbf{identità} degli utenti 
    \item definizione di regole di accesso (\textbf{autorizzazioni}), che stabiliscono
    \textit{chi può fare che cosa}
\end{itemize}

\noindent Definite \textit{discrezionale} perché gli utenti che sono proprietari 
dei dati possono amministrarli come vogliono, \textit{a loro discrezione}; tipicamente, 
non ho un unico amminstratore, ma ci sono più amministratori proprietari delle risorse: è 
in mano a qualcuno stabilire chi può accedere o meno alle risorse (non è escluso avere 
un unico amministratore).

\section{Un esempio di modello}
Si usa la \textit{matrice degli accessi}, è una rappresentazione astratta della 
politica di protezione del sistema.

\noindent Formalmente, è caratterizzato da una tripla $(S, O, A)$ che rappresenta 
lo stato del sistema, dove:
\begin{itemize}
    \item $S$ è il set degli utenti 
    \item $O$ è il set delle risorse, dove $S \subset O$ (un soggetto può essere anche un processo, e può 
    essere anche una risorsa \dots)
    \item $A$ è la matrice, dove:
    \begin{itemize}
        \item le righe corrispondono ai soggetti 
        \item le colonne corrispondono agli oggetti 
        \item $A[s, o]$ riporta i privilegi di $s$ su $o$
    \end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/dac1.png}
\end{figure}

\noindent I cambi di stato del sistema vengono fatti con dei comandi che chiamano delle \textbf{operazioni primitive}:
\begin{itemize}
    \item \texttt{enter} $r$ into $A[s,o]$
    \item \texttt{delete} $r$ from $A[s,o]$
    \item \texttt{create} subject $s$
    \item \dots
\end{itemize}

\noindent Sono della forma:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\linewidth]{images/dac-comm.png}
\end{figure}

\noindent Un esempio:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{images/dac2.png}
\end{figure}

\section{Trasferimento dei privilegi}
Il proprietario dei dati può dare il privilegio anche ad altri utenti.
Può rappresentato in modo formale in due modi differenti:
\begin{itemize}
    \item \textbf{Copy flag (*):} il soggetto trasferisce il privilegio ad altri; mantiene il privilegio
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/transfer1.png}
    \end{figure}
    \item \textbf{Transfer-only flag(+):} il soggetto trasferisce ad altri il privilegio ma perde l'autorizzazione
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/transfer2.png}
    \end{figure}
\end{itemize}

\noindent Partendo da uno stato \textit{sicuro}, non deve accadere che applicando una o più operazioni 
si finisca in uno stato non sicuro.

\section{Implementazione della matrice}
La matrice è spesso sparsa, salvarla sarebbe uno spreco di memoria. Ci sono diversi 
approcci alternativi:
\begin{itemize}
    \item \textbf{Tabella di autorizzazione}; tabella di tuple $(S, O, A)$ non nulle
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\linewidth]{images/auth-table.png}
    \end{figure}
    \newpage
    \item \textbf{Access Control Lists (ACLs)}: store by column; ad ogni risorsa associo una lista 
    che mi dice gli utenti quali operazioni possono fare
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.4\linewidth]{images/acl.png}
    \end{figure}
    \item \textit{Capability lists}; store by row; sono come le precedenti ma vengono fatti storando per utenti
    invece che per risorse. Sono state soppraffatte dalle ACLs
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\linewidth]{images/capability.png}
    \end{figure}
\end{itemize}

\subsubsection{ACLs vs Capability lists}
\begin{itemize}
    \item non richiedono 
    autenticazione del soggetto, ma richiedono la possibilità di verificare che non siano state impropriamente 
    modificate \dots difficile da verificare (per questo non hanno avuto grande successo)
    \item le ACLs funzionano meglio quando fare delle operazioni di revoca per oggetto (ovviamente viceversa se devo fare revoche per soggetto)
\end{itemize}

\section{Debolezze di DAC}
Consentono il controllo solo sull'accesso \textbf{diretto}. Sono vulnerabili ai \textit{trojan 
horses}, ovvero accessi indiretti.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/trojan.png}
\end{figure}

\noindent L'idea è che vengono lasciate delle \textit{operazioni nascoste} in una applicazione per 
poter fare delle operazioni che normalmente non si avrebbe l'autorizzazioni di fare.

$\rightarrow$ è un accesso indiretto; è il processo che Jane sta eseguendo a chiedere l'accesso ai file



\chapter{Mandatory (MAC) policies}
\noindent Partono dall'assunzione che c'è una differenza tra \textit{utente} e \textit{soggetto}; è ciò 
che serve per bloccare i \textit{trojan horses}:
\begin{itemize}
    \item \textbf{Utente:} essere umano (di cui mi fido)
    \item \textbf{Soggetto:} processo nel sistema; opera per conto dell'utente; \textbf{non sono fidati} 
\end{itemize}

\noindent La politica più comune sono quelle \textbf{multilivello}: ogni soggetto e 
oggetto sono classificate con una etichetta. Si differenziano in politiche che si focalizzano su:
\begin{itemize}
    \item confidenzialità (Bell La Padula)
\end{itemize}

\textit{oppure}

\begin{itemize}
    \item integrità (Biba)
\end{itemize}

\section{Classificazione di sicurezza}
Ogni soggetto ed oggetto è associato ad una coppia di elementi:
\begin{itemize}
    \item \textbf{Livello di sicurezza:} livelli su cui è definita una relazione d'ordine totale (li posso mettere \textit{in fila}).
    \begin{center}
        $Secret > Confidential > Unclassified$
    \end{center}
    \item \textbf{Categoria:} insieme di elementi su cui non è definita alcuna relazione di ordinamento; serve 
    per partizionare aree differenti del sistema. Ad esempio, l'università ha un sacco di informazioni di vario 
    tipo: anagrafiche, finanziare, accademiche, \dots. 
    
    \noindent Hanno l'obiettivo di classificarle in classi diverse. Viene fatta 
    sia lato oggetto che lato soggetto.
\end{itemize}

\noindent La combinazione di queste due permette di definire una \textbf{relazione di dominanza:}
\begin{center}
    $(L_1, C_1) \geq (L_2, C_2) \Leftrightarrow L_1 \geq L_2 \land C_1 \supseteq C_2$
\end{center}

Questa relazione soddisfa una serie di proprietà che, in matematica, permette di formare 
un \textit{reticolo} (quando combinata fra tutte le classi); nel nostro caso parliamo 
di \textbf{reticolo di classificazione}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/props.png}
\end{figure}

\noindent Esempio di reticolo di classificazione:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/reticolo.png}
\end{figure}

\newpage
\section{Semantica della classificazione di sicurezza}
\begin{itemize}
    \item \textbf{Classi di sicurezza}
    \begin{itemize}
        \item associato ad un \textit{soggetto}, rilfette la fiducia verso quell'utente; quanto mi fido di quell'utente 
        \item associato ad un \textit{oggetto}, riflette la sensisibilità dell'informazione
    \end{itemize}
    \item Le \textbf{categorie} definiscono l'area di competenza di utenti e dati.
\end{itemize}

\section{Bell La Padula}
È un modello che si preoccupa della confidenzialità (e non del resto).

\noindent Considerando di essere in un ambiente multilivello, l'\textbf{obiettivo} è 
prevenire flussi di informazioni ai livelli più bassi o a classi incomparabili.

\begin{itemize}
    \item \textbf{\textit{Simple property:}} un soggetto $s$ può leggere un oggetto 
    $o$ solo se $\lambda(s) \geq \lambda(o)$
    \item \textbf{\textit{*-property:}} un soggetto $s$ può scrivere un oggetto $o$ solo 
    se $\lambda(o) \geq \lambda(s)$
\end{itemize}

$\Rightarrow$ \textbf{NO READ UP}

$\Rightarrow$ \textbf{NO WRITE DOWN}

\noindent \textit{Se sono Secret, e scrivo un file secret in uno Top-Secret, non è mica un problema 
per la confidenzialità. Potrebbe esserlo se scrivo secret in un file Unclassified (potrebbe causare problemi a livelli di integrità, ma ci stiamo occupando solo di confidenzialità).}

\subsection{Proprietà di sicurezza}
Un sistema viene formalizzato come \textit{stato}
e \textit{transizioni di stato}. 

\noindent Uno stato $v \in V$ è una tripla $(b, M, \lambda)$, dove:
\begin{itemize}
    \item $b$ è l'insieme di triple $(S \times O \times A)$, ovvero l'insieme degli accessi (\textit{soggetto, oggetto, accesso})
    \item $M$ è la matrice di accesso (per rappresentare una politica discrezionale)
    \item $\lambda$ è una funzione che ritorna la classe di sicurezza associata a soggetti e oggetti
\end{itemize}

\noindent Da questa definizione segue che uno stato $(b, M, \lambda)$ è sicuro se rispetta:
\begin{itemize}
    \item \textbf{Simple security:} $\forall (s,o,a) \in b, a = read \Rightarrow \lambda(s) \geq \lambda(o)$
    
    \textit{se la tripla appartiene a b, è perché vale la simple property (classe del soggetto domina quella dell'oggetto)}
    \item \textbf{* property:} $\forall (s,o,a) \in b, a = write \Rightarrow \lambda(o) \geq \lambda(s)$
    
    \textit{se la tripla appartiene a b, è perché vale la * property (classe del oggetto domina quella del soggetto)}
\end{itemize}

\noindent Dato che un sistema può variare nel tempo, occorre formalizzare anche questo aspetto.
Viene definita una \textbf{funzione di transizione di stato} $T: V \times R \rightarrow V$, che 
trasforma lo stato in un altro che soddisfa le due proprietà.

\subsubsection{Sistema sicuro}

Un sistema $(v_0, R, T)$ è sicuro se ogni stato raggiungibile da $v_0$ con una sequenza finita di 
passi da $R$ è sicuro. Formalmente, un sistema è sicuro se:
\begin{itemize}
    \item $v_0$ è sicuro 
    \item $T$ è tale che $\forall v$ raggiungibile da $v_0$ eseguendo una o più richieste 
    da $R$, allora deve valere che:
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{images/blp-ss.png}
    \end{figure}
\end{itemize}

\subsection{\textit{BLP + tranquility}}

L'idea è di controllare ciò che fa $T$, dato che potrebbe dar vita 
a problemi di sicurezza.

\noindent Viene introdotta la \textit{\textbf{tranquility property}}, secondo cui 
il livello di sicurezza associato a soggetti e oggetti non può cambiare.

\noindent Tuttavia, questa restrizione è troppo forte da poter applicare in casi reali;
vengono così introdotti alcuni casi in cui viene \textit{attenuata}:
\begin{itemize}
    \item non tutti i cambi di livello rilasciano informazioni (cambiare verso l'alto può essere ok)
    \item soggetti fidati possono fare downgrade
\end{itemize}


\subsubsection{Altre eccezioni}
\noindent Altre eccezzioni non catturate dal modello, che richiedono di attenuare 
le restrizioni:
\begin{itemize}
    \item \textbf{Data association:} un set di valori associati potrebbe essere classificato 
    \textit{più alto} rispetto ai valori presi singolarmente 
    \item \textbf{Aggregation:} l'aggregazione di tutte le istanze diventa sensibili (ad esempio,
    la posizione di navi da guerra)
    \item \textbf{Sanitizzazione e downgrading:} dopo un certo tempo alcuni dati potrebbero 
    subire un downgrade
\end{itemize}


\subsection{Coesistenza di DAC e MAC}
Il modello BLP permette la coesistenza di DAC e MAC: oltre alle classi e 
alla relazione di dominanza, viene controllata anche la matrice di accesso.
\begin{center}
    DAC property: $b \subseteq \{(s,o,a) | a \in M[s,o]\}$
\end{center}

\noindent Se sono applicati sia DAC che MAC, solo gli accessi che li soddisfano entrambi 
sono garantiti.

\subsection{Limitazioni delle politiche mandatorie}
Le politiche mandatorie sono vulnerabili ai \textbf{canali nascosti}; sono 
canali normalmente non usati per la comunicazione, ma che possono essere usati per 
comunicare in modo illegittimo delle informazioni.

\noindent \textbf{Ogni risorsa del sistema condivisa tra processi di livelli diversi 
può essere usata per creare un canale nascosto}. I canali nascosto possono essere di tipo:
\begin{itemize}
    \item \textbf{Storage:} ad esempio un soggetto top-secret crea un file se vuole comunicare 
    qualcosa, altrimenti no; un soggetto secret prova a scrivere tale file: dall'esistenza o meno 
    deduce l'informazione 
    \item \textbf{Timing:} viene sfruttata la diversa reazione che il sistema può avere in 
    termini di tempo di risposta. 
    
    \noindent Ad esempio, blocco una stampante così che l'utente al livello più basso,
    vedendo il tempo di risposta diverso, capisce che l'altro utente vuole comunicare qualcosa
\end{itemize}

\section{Politche mandatorie per l'integrità}
L'altra proprietà da proteggere (oltre alla confidenzialità) è l'integrità. In 
maniera simile a quanto visto precedentemente, vengono definite:
\begin{itemize}
    \item \textbf{Classi di integrità:}
    di integrità:
    \begin{itemize}
        \item associate agli \textit{utenti} riflettono la fiducia che non modifichi
        informazioni in modo improprio (prima era che non vada a diffondere informazioni sensibili)
        \item associate agli \textit{oggetti} riflettono il grado di fiducia che ho dell'informazione 
        contenuta nell'oggetto e il danno potenziale che modifiche a tale oggetto potrebbero causare
    \end{itemize}
    \item \textbf{Categorie:} defininoscono l'area di competenza di soggetti e oggetti 
\end{itemize}

\section{Modello Biba}
È simmetrico a BLP:
\begin{itemize}
    \item in BLP, non posso leggere verso l'alto e non posso scrivere verso il basso 
    perché non mi fido dei processi (\textit{chi mi dice che un processo non legge informazioni 
    TS e le scrive in oggetti S?})
    \item in Biba, i soggetti non possono scrivere a livelli più alti, altrimenti comprometterebbero 
    l'integrità; non posso leggere a livello più basso perché potrei avere informazioni non affidabili
\end{itemize}

$\rightarrow$ vengono fatti ragionamenti opposti perché si hanno obiettivi diversi da raggiungere

\noindent La politica di integrità prevede:
\begin{itemize}
    \item \textbf{Simple property:} un soggetto $s$ può leggere un oggetto $o$ solo 
    se $\lambda(o) \geq \lambda(s)$
    \item \textbf{*-property:} un soggetto $s$ può scrivere un oggetto $o$ solo se $\lambda(s) \geq \lambda(o)$
    
    \textit{NB: viene segnalato al sistema ma non bloccato}
\end{itemize}

$\Rightarrow$ \textbf{NO READ DOWN}

$\Rightarrow$ \textbf{NO WRITE UP}

\subsection{Politiche alternative}
Due varianti per rilassare le restrizioni:
\begin{itemize}
    \item \textbf{\textit{Rilassare l'operazione lettura:}}
    
    \noindent Un soggetto $s$ può leggere quasiasi oggetto $o$. Dopo l'accesso, 
    $\lambda(s):= glb(\lambda(s), \lambda(o))$.
    \begin{itemize}
        \item \textit{se leggo un informazione a livello più basso, anche le mie azioni 
        si basano su informazioni meno affidabili; per questo viene abbassato il livello di integrità
        al soggetto (nel caso in cui $\lambda(o) < \lambda(s)$)}
        \item \textit{Drawback:} l'ordine delle operazioni influenza i privilegi del soggetto
    \end{itemize}
    \item \textbf{\textit{Rilassare l'operazione di scrittura:}}

    \noindent Un soggetto $s$ può scrivere qualsiasi oggetto $o$. Dopo l'accesso, 
    $\lambda(o):= glb(\lambda(s), \lambda(o))$
    \begin{itemize}
        \item \textit{posso cambiare informazioni affidabili con altre meno affidabili; per questo 
        devo cambiare la classe di integrità dell'oggetto}
        \item \textit{Drawback:} non blocca questo tipo di scritture ma si limita a segnararle
    \end{itemize}
\end{itemize}

\subsection{Limitazioni di Biba}
Il vero problema di Biba è che guarda solo un aspetto limitato dell'integrità 
delle informazioni; non basta per proteggere l'integrità.

\newpage
\section{Applicazione di BLP nelle basi di dati}

È prima di tutto necessario decidere il livello di granularità a cui associare 
le classi di sicurezza per applicare la politica mandatoria:
\begin{itemize}
    \item relazione 
    \item attributo 
    \item tupla 
    \item elemento
\end{itemize}

\subsection{Modello relazionale classico}
Ogni relazione è caratterizzata da:
\begin{itemize}
    \item \textbf{Schema} della relazione $R(A_1, \dots, A_n)$, indipendente dallo stato 
    \item \textbf{Istanza} della relazione, dipendente dallo stato, composta 
    \\ da tuple $(a_1, \dots, a_n)$
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/classic.png}
\end{figure}

\noindent Gli \textbf{attributi chiave} identificano univocamente le tuple:
\begin{itemize}
    \item due tuple non possono avere la stessa chiave 
    \item le chiavi non possono avere valore \texttt{null}
\end{itemize}

\subsection{Multilevel DBMSs}
Ogni relazione è caratterizzata da:
\begin{itemize}
    \item \textbf{Schema} delle relazione $R(A_1,C_1,\dots,A_n,C_n)$, indipendente
    dallo stato 
    \begin{itemize}
        \item $C_i$, con $i = 1, \dots, n$, è il range delle classificazioni di sicurezza
    \end{itemize}

    $\rightarrow$ vengono aggiunti altri $n$ attributi per tenere traccia delle classificazioni
    \item \textbf{Set di instanze} della relazione $R_c$, dipendente dallo stato; una istanza 
    per ogni classe $c$. Ciascuna istanza è composta da tuple $(a_1,c_1,\dots,a_n,c_n)$

    \noindent L'istanza a livello $c$ contiene solo gli elementi la cui classificazione è 
    dominata da $c$
\end{itemize}

\subsubsection{Controllo degli accessi}
Il controllo degli accessi viene fatto applicando il modello BLP:
\begin{itemize}
    \item \textit{no read up}
    \item \textit{no write down further restricted} 
    
    $\rightarrow$ ogni soggetto può scrivere solo al \textbf{suo} livello
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/multi-dbms.png}
\end{figure}

\subsubsection{Modello relazionale multilivello}
Per ogni tupla in una relazione multilivello:
\begin{itemize}
    \item gli attributi chiave devono avere la \textbf{stessa classe}, altrimenti 
    potrebbero avere valore nullo (riesco ad inferire qualcosa)
    \item gli \textbf{attributi non chiave devono dominare gli attributi chiave}, 
    altrimenti potrei vedere un attributo senza l'identificatore
\end{itemize}

\section{Polinstanziazione}
La polinstanziazione consiste nella \textbf{presenza di oggetti con lo stesso nome 
ma classifiazione diversa}; ovvero, tuple diverse con la stessa chiave ma:
\begin{itemize}
    \item diversa classificazione per la chiave (\textit{polyinstantiated tuples})
    \item valori e classificazione diversi per uno o più attributi (\textit{polyinstantiated elements})
\end{itemize}

\noindent Il sistema si occuperà di fare il \textit{merge} tra le varie tuple con classificazione 
diversa, restituendo sempre una sola tupla.


\subsection{Polinstanziazione invisibile}
Un soggetto a \textit{livello basso} inserisce dati in un campo che contiene già valori 
a livello più alto; il soggetto non vede i dati già esistenti.


\subsubsection{Esempio - Tuple polinstanziate}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/poly1.png}
\end{figure}

\begin{itemize}
    \item Un utente U vuole inserire una tupla per Ann, dato che quella già esistente non la vede 
    \item L'inserimento di questa tupla viene permesso, dunque mi ritrovo con due tuple con lo \textbf{stesso 
    valore per l'attributo chiave} (Ann), ma con \textbf{classificazione diversa}
    \begin{itemize}
        \item non può essere impedito, perché altrimenti inferisci che Ann c'è ma non la vedi (\textbf{\textit{information leakage}})
        \item non può essere modificata la tupla già esistente (\textit{\textbf{loss of integrity}})
    \end{itemize}
\end{itemize}

\subsubsection{Esempio - Elementi polinstanziati}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/poly2.png}
\end{figure}

\begin{itemize}
    \item Un utente U vuole fare update del salario di Sam (dato che non lo può vedere)
    \item Viene fatta un'altra tupla, dunque mi ritrovo con due tuple con \textbf{gli stessi valori per 
    l'attributo chiave, ma valori diversi per attributi non chiave}
    \begin{itemize}
        \item l'operazione non può essere impedita (\textit{\textbf{information leakage}})
        \item viene creata un'altra tupla perché la modifica viene fatta con una classe minore, 
        quindi la nuova informazione è meno affidabile di quello che ho già (\textit{\textbf{loss of integrity}})
    \end{itemize}
    
\end{itemize}

\subsection{Polinstanziazione visibile}
Un soggetto ad \textit{livello alto} inserisce dati in un campo che contiene già valori 
a livello più basso; il soggetto vede i dati già esistenti.

\subsubsection{Esempio - Tuple polinstanziate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/poly3.png}
\end{figure}

\begin{itemize}
    \item Un utente S vuole modificare una tupla U 
    \item Viene creata una nuova tupla, così che la tupla U non viene toccata (senza 
    quindi creare un canale di inferenza) e salvando la nuova informazione
    \begin{itemize}
        \item L'operazione non può essere impedita, dato l'informazione S è più affidabile di quella U (\textit{\textbf{denial of service}})
        \item La tupla esistente non può essere direttamente modificata, altrimenti gli utenti U smetterebbero di 
        vederla e potrebbero inferire informazioni (dato che nell'update si andrebbe a cambiare anche la classe 
        di classifiazione d a U a S) (\textit{\textbf{information leakage}})
    \end{itemize}
\end{itemize}


\subsubsection{Esempio - Elementi polinstanziati}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/poly4.png}
\end{figure}

\begin{itemize}
    \item Un utente S vuole modificare il salario di Sam che è U 
    \item Viene fatta una nuova tupla, dove cambia il \textbf{valore e la classe di classificazione}, da 
    U a S 
    \begin{itemize}
        \item come prima, non posso bloccare la richiesta (\textit{\textbf{denial of service}})
        \item come prima, non posso modificare direttamente la tupla esistente (\textit{\textbf{information leakage}})
    \end{itemize}
\end{itemize}

\subsubsection{Esempio di domanda all'esame}
\textcolor{red}{Parlami della polinstanziazione.} 

\noindent La polinstanziazione può essere a livello di tupla o di elemento, ed ognuna di queste 
può essere visibile o non visibile\dots

\subsection{Considerazioni}
La polinstanziazione viene fatta perché è l'unico modo per fare ciò che viene richiesto 
senza creare inferenza. 

\noindent Tuttavia, è necessario usarla perché si è cercato di applicare la politica ad un 
livello di granularità molto fine (elemento):
\begin{itemize}
    \item ho il vantaggio di avere più controllo 
    \item ho lo svantaggio di dover ricorrere alla polinstanziazione
\end{itemize}

\noindent Tuttavia, gli svantaggi pesano più degli svantaggi, per cui tipicamente viene applicata a 
livello di tupla e non di elemento.

\subsubsection{Uso di \texttt{restricted}}

\noindent Un'alternativa è quella di usare \texttt{restricted} al posto di \texttt{null} quando 
un utente non può vedere un valore; altrimenti solo con \texttt{null} non capisco se è perché non esiste 
o perché non lo posso vedere.

\subsubsection{Cover story}
L'aspetto positivo della polinstanziazione sono le cover story, ovvero \textit{qualcosa che ti faccio 
vedere come vero per coprire la verità}.

\subsection{Multilevel DBMS - Architetture}
Possiamo aver due scenari a seconda del livello di fiducia:
\begin{itemize}
    \item \textbf{\textit{Mi fido di chi gestisce le informazioni:}} vengono memorizzate 
    tutto nello stesso database, perché mi fido che i livelli di sicurezza e 
    la politica mandatoria vengano rispettati
    \item \textbf{\textit{Non mi fido di chi gestisce le informazioni:}} uso diversi database
    ciascuno dei quali si occupa di gestire un determinato livello di sicurezza, per evitare di 
    mischiare informazioni di livelli diversi; ci deve comunque essere fiducia a livello operativo,
    che si occuperà di gestire le richieste
\end{itemize}




\chapter{RBAC policies}
Le politiche basate su ruolo sono innovative rispetto a quelle tradizionali come DAC e MAC.

\noindent Si passa dall'avere una tripla $(s,o,a)$ in cui si ha un singolo soggetto ad avere un gruppo 
di soggetti; viene così introdotto il concetto di \textbf{ruolo}, ovvero un insieme di privilegi.
\begin{itemize}
    \item attivando un ruolo $r$, ad un utente sono concessi tutti gli accessi che sono concessi a $r$
    \item l'idea è di avere delle autorizzazioni non sulla base della propria identità, ma sulla base 
    del ruolo che si ricopre
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/rbac.png}
\end{figure}

\noindent Il modello è caratterizzato da tre entità:
\begin{itemize}
    \item utenti, ovvero le persone fisiche che possono attivare un ruolo 
    \item ruoli, ovvero un insieme di privilegi
    \item oggetti, ovvero le risorse a cui è possibile accedere
\end{itemize}

\noindent \underline{Nota bene:}
\begin{itemize}
    \item \textit{gruppo} $\rightarrow$ insieme di \textit{utenti}
    \item \textit{ruolo} $\rightarrow$ insieme di \textit{privilegi}
\end{itemize}

\section{Gerarchia di specializzazione dei ruoli}

È possibile definire una gerarchia di specializzazione sui ruoli.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/ger-ruoli.png}
\end{figure}

\noindent Questa induce una propagazione di autorizzazioni:
\begin{itemize}
    \item se ad un ruolo $r$ viene dato un privilegio, automaticamente 
    viene dato anche a tutte le specializzazioni di $r$
    \item se un utente $u$ è autorizzato ad attivare un ruolo $r$, automaticamente
    è autorizzato ad attivare anche tutti i ruoli che sono una generalizzazione di $r$
\end{itemize}

\section{Vantaggi}
\begin{itemize}
    \item La \textbf{specifica delle autorizzazioni è semplificata}
    \item La gerarchia di ruoli fa in modo di avere delle \textbf{autorizzazioni implicite} 
    \item È possibile specificare \textbf{restrizioni sui ruoli} che un utente può attivare, come 
    cardinalità o mutua esclusione 
    \item Si definisce un ruolo per ogni \textit{attività nell'organizzazione}, in modo 
    che ciascun utente abbia il \textbf{privilegio minimo}, ovvero solo i privilegi strettamente 
    necessari 
    \item Permette la \textbf{separazione dei compiti}
\end{itemize}

\section{Altri modelli basati su ruoli}
Ci sono altri aspetti con l'obiettivo di estendere ancora di più 
il potere esprissivo di questo modello:
\begin{itemize}
    \item vincoli sulla propagazione dei ruoli 
    \item fare riferimento anche all'identità del soggetto; si mischia il concetto di ruolo 
    con quello di identità 

    \noindent \textit{La mia segretaria può leggere i miei file}
    \item separazione dei compiti dinamica
\end{itemize}

\chapter{Politche amministrative}
È necessario avere una politica amministrativa che stabilisca chi può definire e gestire 
le autorizzazioni del sistema; ci sono due scenari:
\begin{itemize}
    \item \textbf{Centralizzata:} ho un unico soggetto che definisce le autorizzazioni; tipico 
    delle politiche mandatorie 
    \item \textbf{Ownership:} chi crea le risorse nel sistema ne diventa proprietario, e può definire 
    su esse le autorizzazioni; a differenza del caso precedente l'amminstrazione è \textit{distribuita}.
\end{itemize}

\section{Amministrazione decentralizzata}
L'amministrazione decentralizzata deve rispondere in modo non ambiguo ad una serie 
di domande:
\begin{itemize}
    \item Si possono delegare autorizzazioni? In modo libero o con restrizioni? 
    \item Chi può revocare autorizzazioni? 
    \item Cosa succede alle autorizzazioni concesse da un utente a cui ho rimosso 
    l'autorizzazione di delegare autorizzazioni?
\end{itemize}

\noindent In base a come si risponde a queste domande si otterranno delle politiche diverse; 
da una parte sono potenti, dall'altro lato è difficile gestire tutti questi aspetti.

\section{Esempio con SQL}
In SQL è possibile creare politiche decentralizzate basate sul concetto di \textit{ownership}:
\begin{itemize}
    \item è possibile concedere la possibilità di delegare una autorizzazione con \texttt{grant-option}
    \item si crea in questo modo una \textit{catena di autorizzazioni}
    \item le autorizzazioni possono essere revocate solo da chi le ha concesse 
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/grant.opt.png}
\end{figure}

\subsection{Revoca delle amministrazioni}
\textit{Se revoco il privilegio a qualcuno che a sua volta lo ha dato a qualcun'altro, 
quello concesso da questo utente deve essere tolto a sua volta o deve rimanere?}

\noindent Ci sono due modi diversi di operare:
\begin{itemize}
    \item \textbf{with cascade:} la revoca è ricorsiva; bisogna fare attenzioni ai cicli, devo sempre 
    avere un grafo connesso
    \item \textbf{without cascade:} significa che se voglio togliere un privilegio senza il 
    quale un altro privilegio non potrebbe esistere, allora non è possibile fare l'operazione di 
    revoca (prima dovrebbe essere revocato l'altro privilegio)
\end{itemize}

\subsubsection{Esempio}
Ogni arco rappresenta una autorizzazione alla stessa risorsa con la stessa modalità 
di accesso.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/revoke-rec.png}
\end{figure}

\newpage
\subsubsection{Esempio con tempo}
Originariamente su SQL la revoca era basata sul concetto di tempo (ora 
non più).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/rev-time.png}
\end{figure}

\noindent In questo caso, Bob può dare l'autorizzazione a Frank perché
l'istante 70 viene dopo l'istante 40 (quello della revoca).

\subsection{Possibile estensione}
Non è detto che si voglia sempre avere una revoca ricorsiva; una possibile alternativa 
prevede di specificare chi fa la revoca come colui che dà l'autorizzazione (che viene tolta).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/rev-alt.png}
\end{figure}

\chapter{Chinese Wall}
È il primo modello che ha introdotto il concetto di \textbf{separazione dei beni} per proteggere 
la segretezza; 
l'obiettivo è prevenire flussi di informazione tra entità che sono in conflitto di interesse.

\noindent Gli oggetti sono organizzati gerarchicamente in tre livelli:
\begin{itemize}
    \item \textbf{oggetti base} che contengono informazioni da proteggere 
    \item \textbf{company dataset}, ciascuna con i suoi oggetti base 
    \item \textbf{classi di conflitto di interesse}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/cw.png}
\end{figure}

\section{Proprietà}

\subsection{Simple security rule}
Un soggetto $s$ può \textbf{accedere} ad un oggetto $o$ solo se:
\begin{itemize}
    \item $o$ è nello stesso company dataset degli altri oggetti a cui $s$ ha già acceduto 
    \item $o$ appartiene ad una classe di conflitto di interesse diversa da quelle a cui $s$ ha già acceduto
\end{itemize}


\subsection{*-property}
Un soggetto $s$ può \textbf{scrivere} un oggetto $o$ solo se:
\begin{itemize}
    \item l'accesso è consenito dalla simple security rule, e 
    \item nessun oggetto può essere letto da $s$ (secondo le autorizzazioni) che:
    \begin{itemize}
        \item è in un company dataset diverso da quello di $o$, e 
        \item contiene informazioni \textit{non sanitizzate}
    \end{itemize}
\end{itemize}

\noindent Questa proprietà previene la collusione tra utenti.

\subsection{Considerazioni}
Nella pratica non è usato, si potrebbe addirittura arrivare al punto in cui il sistema diventa 
inutilizzabile; inoltre, bisogna mantenere uno storico degli accessi.

\noindent Tuttavia, è importante per l'introduzione del concetto di separazione dinamica dei compiti.

\section{Separazione dei compiti}
Il principio è quello di dividere le autorizzazioni in modo che nessun utente abbia \textbf{troppo potere} 
in modo da poter abusare del sistema. Può essere fatta in due modi:
\begin{itemize}
    \item \textbf{Statica:} vengono definite in modo esplicito tutte le autorizzazioni 
    \item \textbf{Dinamico:} di base tutti possono fare tutto, ma per determinate operazioni 
    viene richiesto che almeno $X$ utenti siano coinvolti
\end{itemize}


\chapter{Espansione delle autorizzazioni nelle politiche discrezionali}

Alcune possibili espansioni possono essere:
\begin{itemize}
    \item non definire le politiche sui singoli soggetti, ma usare \textbf{gruppi di utenti}: tutti 
    i soggetti che appartengono ad un gruppo hanno il privilegio. Le autorizzazioni sono definite a livello 
    di gruppo, non più sull'identità del soggetto.

    \noindent Il concetto di gruppo può essere esteso anche ad oggetti e modalità di accesso.
    \item Si introducono delle \textbf{condizioni} da soddisfare affinché l'autorizzazione sia valida; ad esempio:
    \begin{itemize}
        \item posso accedere solo dalla rete interna 
        \item posso accedere solo dalle 8 alle 20
        \item \dots
    \end{itemize}
\end{itemize}

\subsubsection{Autorizzazioni negative}

\noindent L'utilità di questa astrazione è limitata se non è possibile esprimere 
delle \textbf{eccezioni}. Per questo motivo si possono esprimere anche \textbf{autorizzazioni 
negative}. Ad esempio:
\begin{itemize}
    \item \texttt{(Employees, read, file, +)}
    \item \texttt{(Sam, read, file, -)}
\end{itemize}

\noindent Questo può indurre ad avere \textbf{inconsistenza} nella politica di autorizzazione. Come
dovrebbe gestirla il sistema?

\section{Permessi e negazioni}
\begin{itemize}
    \item \textbf{Politica aperta:} tutti possono fare tutto, a meno che sia vietato in maniera esplicita 
    \item \textbf{Politica chiusa:} nessuno può fare niente, a meno che ci sia una autorizzazione esplicita che lo permetta
\end{itemize}

\noindent Nella pratica si usanno approcci ibridi, ad esempio una autorizzazione 
positiva a livello di gruppo ma negativa a livello di utente. 

\noindent Questo porta con sé due possibili conseguenze:
\begin{itemize}
    \item \textbf{inconsistenza:} per un accesso c'è si + che - 
    \item \textbf{incompletezza:} per un accesso non c'è né + né -
    \begin{itemize}
        \item esigere che per ogni possibile sia specificato qualcosa è \textit{too heavy}; si 
        può risolvere usando una politica di \textbf{default}
    \end{itemize}
\end{itemize}

\subsection{Politiche per la risoluzione dei conflitti}
Alcune possibile politiche possono essere:
\begin{itemize}
    \item \textbf{denials-take-precedence} (vince la negativa)
    \item \textbf{most-specific-takes-precedence} (vince la più specifica)
    \item \textbf{most-specific-along-path-takes-precedence} (tutti i percorsi che vanno verso 
    la radice vanno considerati separatamente)
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/conflict.png}
\end{figure}

\noindent È possibile definire due classi di autorizzazioni per aiutare 
la risoluzione dei conflitti (ad esempio nel caso una sia più specifica 
rispetto al soggetto e una rispetto all'oggetto):
\begin{itemize}
    \item \textbf{strong}: le autorizzazioni forti non possono essere sovrascritte
    \item \textbf{weak}: le autorizzazioni deboli possono essere annullate
\end{itemize}

\noindent \textbf{Altre politiche di risoluzione dei conflitti:}
\begin{itemize}
    \item Priorità esplicità: le autorizzazioni a priorità esplicita hanno priorità esplicite associate (difficile da gestire)
    \item La forza posizionale delle autorizzazioni dipende dall'ordine nell'elenco delle autorizzazioni 
    \item La forza delle autorizzazioni dipendente dal concedente dipende da chi le ha concesse 
    \item La forza delle autorizzazioni dipendente dal tempo dipende dal momento in cui sono state concesse (esempio: vincono più recenti) 
\end{itemize}













\end{document}