\documentclass{report}
\usepackage{graphicx} % Required for inserting images
\usepackage[italian]{babel}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{xcolor}

\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}


\title{Protezione e Integrità dei Dati nel Cloud}
\date{Parte V}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Encryption}
Il \textit{server} potrebbe essere \textbf{\textit{honest-but-curious}}, non dovrebbe 
avere accesso alle risorse; voglio garantire confidenzialità anche rispetto a lui.

Un modo per ottenerla è utilizzare l'\textit{encyption}: si aggiunge 
un livello di protezione attorno ai dati sensibili che li rende non 
leggibili a chi non è autorizzato. 

Di base voglio avere una criptazione dei dati; il problema è il \textbf{bilanciamento tra protezione e funzionalità}, ovvero sulle \textit{query} che è possibile fare sui dati.

\subsubsection{Approcci per accesso a diversi livelli di granularità}

\begin{itemize}
    \item \textbf{\textit{Keyword-based searching:}} passo un \textit{token} già criptato 
    che viene usato per fare ricerca sui dati criptati (voglio trovare dove c'è una certa parola/espressione booleana)
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.4\linewidth]{images/encryption/token-based-search.png}
    \end{figure}
    \item \textbf{Crittografia omomorfica:} crittografia che supporta le operazioni direttamente sul cifrato
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.4\linewidth]{images/encryption/homomorphic.png}
    \end{figure}
    \item \textbf{\textit{Encryption Schemas:}} ogni colonna può essere cifrata con un diverso schema crittografico 
    (\textit{random, add homomorphic, deterministic, order preserving, \dots})
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.3\linewidth]{images/encryption/schemas.png}
    \end{figure}
    \item \textbf{\textit{Onion Encryption:}} cifro i dati con diversi livelli \textit{a cipolla}, ognuno dei quali
    supporta l'esecuzione di una specifica \textit{query SQL}; l'idea è che \textit{scopro il dato solo quando mi serve}
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.8\linewidth]{images/encryption/onion.png}
    \end{figure}
    \item \textbf{Indicizzazione:} associo degli indici ai metadati
    \begin{figure}[ht]
        \centering
        \includegraphics[width=0.6\linewidth]{images/encryption/indicizzazione.png}
    \end{figure}
    Nella seconda tabella: nella seconda colonna c'è la tupla criptata; nelle ultime tre ci sono gli attributi;
    si possono avere diversi tipi di indicizzazione:
    \begin{itemize}
        \item \textbf{\textit{Direct} $(1:1)$}
        
        \textcolor{darkgreen}{\textbf{+}} riesco a fare query precise
        
        \textcolor{red}{\textbf{-}} soggetto ad attacchi di frequenza
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.85\linewidth]{images/encryption/index-direct.png}
        \end{figure}
        \item \textbf{\textit{Bucket} $(n:1) \rightarrow$} indicizzazione con collisione; ho diversi valori 
        che sono \textbf{mappati allo stesso indice}

        \textcolor{darkgreen}{\textbf{+}} non ho più attacchi di frequenze

        \textcolor{darkgreen}{\textbf{+}} supporta query di uguaglianza (\textit{se un valore è uguale ad un altro})
        
        \textcolor{red}{-} i risultati avranno delle tuple spurie

        \textcolor{red}{-} è ancora possibile fare qualche leakage
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.85\linewidth]{images/encryption/bucket-index.png}
        \end{figure}
        \textit{In questo caso sono comunque esposto perché asma ha 3 occorrenze, dunque sarà per forza associata ad $\alpha$}

        \item \textbf{\textit{Flattened} $(1:n) \rightarrow$} ciascun indice deve avere lo stesso numero di occorrenze; significa che 
        i valori che hanno più occorrenze sono associati ad indici diversi

        \textcolor{darkgreen}{\textbf{+}} rimuovo la possibilità di fare attacchi di inferenze

        \textcolor{red}{\textbf{-}} sono esposto ad osservazioni dinamiche (magari certi dati sono sempre cercati assieme) 
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.85\linewidth]{images/encryption/flattened-index.png}
        \end{figure}

        \item \textbf{\textit{Partition-based:}}
        \begin{enumerate}
            \item si partiziona il dominio di un attributo
            \item a ciascuna partizione si assegna un'etichetta
            \item il valore in chiaro viene sostituito dall'etichetta
        \end{enumerate}

        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.6\linewidth]{images/encryption/partion-based-index.png}
        \end{figure}

        \noindent Supporta \textit{query} dove le condizioni sono espressioni booleane del tipo:

        - \textit{Attribute} \texttt{op} \textit{Value}

        - \textit{Attribute} \texttt{op} \textit{Attribute}

        dove \texttt{op}$=\{ =, <, >, \leq, \geq \}$

        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.6\linewidth]{images/encryption/partition-based-ex.png}
        \end{figure}

        \noindent \textbf{Esecuzione delle query:}

        \noindent Ogni query $Q$ sul DB in chiaro viene tradotta in:
        \begin{enumerate}
            \item una query $Q_s$ da eseguire sul server $\rightarrow$ query sull'indice per ottenere le tuple criptate
            \item una query $Q_c$ da eseguire sul client $\rightarrow$ decriptare il risultato della query precedente e filtrare le tuple spurie
        \end{enumerate}

        La traduzione dovrebbe essere fatta in modo tale che il server sia responsabile 
        della maggior parte del lavoro.

        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.8\linewidth]{images/encryption/query-ex-1.png}
        \end{figure}
        \begin{figure}[ht]
            \centering
            \includegraphics[width=0.8\linewidth]{images/encryption/query-ex-2.png}
        \end{figure}

        \newpage
        \item \textbf{\textit{Hash-based:}} basate sul concetto di \textit{one-way hash function}; ogni
        attributo viene mappato ad un indice utilizzando una funzione di hash sicura.

        \noindent Dat una funzione $h$ e il dominio degli attributi $D_i$, diciamo che $h$ è \textbf{sicura} se:
        \begin{enumerate}
            \item $\forall x, y \in D_i \implies h(x) = h(y)$ (\textbf{determinismo}) 
            \item dati due valori $x, y \in D_i$ tali che $ x \neq y$, potremmo avere che $h(x)=h(y)$ (\textbf{collisione}, per proteggermi da attacchi di frequenza)
            \item la distanza dei valori in chiaro deve essere \textbf{indipendente} dalla distanza dei valori di hash (\textit{strong mixing})
        \end{enumerate}

        \noindent Questo metodo supporta \textit{query} dove le condizioni sono espressioni booleane del tipo:
        \begin{itemize}
            \item $ Attribute = Value$
            \item $Attribute_1 = Attribute_2$, se sono indicizzati con la stessa funzione di hash
        \end{itemize}
        
        \noindent La traduzione funziona come nel metodo \textit{partion-based}; non 
        sono supportate \textit{query di range}. 
    \end{itemize}
\end{itemize}

\subsubsection{Interval-based queries}
\begin{itemize}
    \item Le tecniche di indicizzazione che preservano l'ordine supportano 
    query di range, ma sono esposte ad inferenza
    \item Le tecniche di incizzazione che \textit{non} preservano l'ordine non sono esposte 
    ad inferenza, ma non supportano query di range
\end{itemize}

$\rightarrow$ viene calcolato un $B_+ -tree$ dal client, ed ogni nodo viene criptato come un tutt'uno; successivamente 
per rispondere alle query l'albero viene visitato (in ambiente trusted).

\newpage
\section{\textit{Searchable Encryption}}
\subsection{\textit{Order preserving encryption}}
\begin{itemize}
    \item \textbf{\textit{Order Preserving Encryption Schema (OPES):}} prende in input una distribuzione target 
    di valori per gli indici ed applica una trasformazione che preserva l'ordine e rispecchia 
    la distribuzione di input.

    \textcolor{darkgreen}{\textbf{+}} la comparazione può essere fatta direttamente sui dati criptati 

    \textcolor{darkgreen}{\textbf{+}} le query non producono tuple spurie 

    \textcolor{red}{\textbf{-}} vulnerabile ad attacchi di inferenza

    \item \textbf{\textit{Order Preserving Encryption with Splitting and Scaling (OPESS):}}
    
    Questo schema crea degli indici in modo tale che la loro distribuzione delle frequenze sia piatta.
\end{itemize}

\subsection{\textit{Fully homomorphic encryption}}

\begin{itemize}
    \item Permette una performante computazione specifica sui dati criptati 
    \item Decriptando il risultato, si ottiene lo stesso risultato delle stesse operazioni sui dati in chiaro
\end{itemize}

\newpage
\section{Esposizione all'inferenza}

Ci sono due requisiti conflittuali quando si parla di 
\textit{indicizzare} dati:
\begin{itemize}
    \item gli indici dovrebbero fornire una \textbf{esecuzione delle query efficiente}
    \item gli indici non dovrebbero aprire porte ad attacchi di \textbf{inferenza} e \textit{linking}
\end{itemize}

$\rightarrow$ diventa importante misurare quantitativamente il livello di esposizione dovuto 
alla pubblicazione degli indici:

\centering $\epsilon =  $ \textit{Coefficiente di Esposizione}

\noindent La computazione del \textit{Coefficiente di Esposizione} dipende da diversi fattori:
\begin{itemize}
    \item \textbf{Metodo di incizzazione utilizzato}
    \begin{itemize}
        \item \textit{direct encryption}
        \item \textit{hashing}
    \end{itemize}
    \item \textbf{Conoscenza pregressa dell'attaccante}
    \begin{itemize}
        \item $Freq + DB^k$
        \item $DB + DB^k$
    \end{itemize}

    \noindent In entrambi i casi l'attaccante può risalire alla funzione di incizzazione.
\end{itemize}

\raggedright

\subsection{Direct Encryption}
\subsubsection{\textbf{Freq + $DB^k$}}

\begin{itemize}
    \item La corrispondenza tra indice e valore in chiaro può essere determinata sulla base 
    del numero di occorenze di indice/valore

    $\rightarrow$ \textbf{Protezione base:} i valori con lo stesso numero di occorenze sono indistinguibili per l'attaccante
    \item Valutazione dell'esposizione dell'indice basata sulla relazione di equivalenza
    in cui i valori di indice/valore con lo stesso numero di occorrenze
    appartengono alla stessa classe

    $\rightarrow$ L'esposizione di un indice nella classe di equivalenza $C$ è $1 / |C|$ 
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\linewidth]{images/encryption/direct-freq-db.png}
\end{figure}

\newpage
\begin{itemize}
    \item nella tabella \textit{Quotient} ci sono le classi di equivalenza a cui appartengono gli indici
    \item nella tabella \textit{Inverse Cardinality} c'è $1/|C|$ , si interpreta come:
    \begin{itemize}
        \item \textit{c'è 1 di 6 valori che non so distinguere}
        \item \textit{c'è 1 di 4 valori che non so distinguere}
        \item Sta esprimendo l'incertezza; più sarà grande $|C|$, più avrò incertezza 
        
        $\rightarrow$ quelli con $1/1$ rappresentano un problema dato che non c'è incertezza
    \end{itemize}
    \item A \textbf{livello di tupla} l'incertezza è il \textbf{prodotto} delle incertezze
    \item A \textbf{livello di tabella} faccio la \textbf{media} dell'esposizione delle tuple ($\epsilon$)
\end{itemize}

\subsubsection{DB + $DB^k$}
\begin{itemize}
    \item Grafo \textbf{\textit{Row-Column-Value}} non-direzionato a 3 colori
    \begin{itemize}
        \item un vertice di colore \textit{column} per ogni attributo 
        \item un vertice di colore \textit{row} per ogni tupla 
        \item un vertice di colore \textit{value} per ogni valore distinto in una colonna
        \item un arco connette ogni valore alla riga e colonna in cui compare
    \end{itemize}
    \item RCV sui valori in chiaro è uguale a quello sugli indici
    \item posso avere una misura del grado di esposizione guardando quanto \textit{un nodo si confonde} (automorfismo)
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/encryption/direct-db-dbk1.png}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/encryption/direct-db-dbk2.png}
\end{figure}

\newpage
Per \textit{Equitable Partion} si intende un insieme di vertici che costituiscono un automorfismo.

\noindent L'esposizione si calcola come il rapporto tra il numero di \textit{equitable partition} e il numero totale degli elementi.

\newpage
\subsection{Hashing}
\subsubsection{Freq + $DB^k$}
\begin{itemize}
    \item La funzione di hash è caratterizzata da un \textit{fattore di collisione}, ovvero il numero 
    di valori che in media collidono sullo stesso indice 
    \item Sono possibili diversi mapping dei valori negli indici, in relazione ai vincoli imposti dalle frequenze 
    \item Per ogni mapping si calcola il coefficiente di esposizione
\end{itemize}

\subsubsection{DB + $DB^k$}
\begin{itemize}
    \item i grafi RCV tra dati in chiaro e criptati non sono uguali, dato che \textit{vertici diversi} nel grafo in chiaro 
    potrebbro collassare nello \textit{stesso vertice} nel grafo criptato
    \item il numero di archi che collega i vertici \textit{row} ai vertici \textit{value} è lo stesso
    \item il problema diventa trovare un \textit{matching corretto} tra gli archi del grafo in chiaro e quello criptato
\end{itemize}

\newpage
\section{Bloom Filter}
Il \textit{Bloom Filter} sta alla base della costruzione di alcune tecniche 
di indicizzazione; è un metodo efficiente per codificare l'appartenenza a un insieme.

\begin{itemize}
    \item set di $n$ elementi ($n$ è grande)
    \item vettore di $l$ bit ($l$ è piccolo)
    \item $h$ funzioni di hash indipendenti $H_i : \{0,1\}^* \rightarrow [1,l]$
    \item \textbf{Insert x:} set a 1 i bit corrispondenti a $H_1(x), H_2(x), \dots, H_h(x)$
    \item \textbf{Search x:} Computare $H_1(x), H_2(x), \dots, H_h(x)$ e verificare se quei valori sono settati a 1 nel vettore
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{images/encryption/bloom-filter.png}
\end{figure}

\begin{itemize}
    \item è una generalizzazione dell'hashing (\textit{bloom filter} con 1 funzione di hash equivale all'hash ordinario)
    
    \textcolor{darkgreen}{\textbf{+}} efficiente nello spazio
    
    \textcolor{red}{\textbf{-}} gli elementi non possono essere rimossi

    \item ha una costante di probabilità di ottenere un falso positivo

    \textcolor{red}{\textbf{-}} teoricamente non accettabile 

    \textcolor{darkgreen}{\textbf{+}} nella pratica è accettabile perché il costo viene messo in relazione ai guadagni in termini di spazio
\end{itemize}

\newpage
\section{Integrità dei Dati}
Due aspetti:
\begin{itemize}
    \item \textbf{Integrità in Storage:} i dati devono essere protetti da modifiche non autorizzate
    
    $\rightarrow$ update non autorizzate devono essere rilevati
    \begin{itemize}
        \item si ottiene utilizzando la \textbf{firma digitale} a livello di tupla (a livello di cella sarebbe troppo costoso)
    \end{itemize}

    \item \textbf{Integrità nelle query:} i risultati delle query devono essere corretti e completi
    
    $\rightarrow$ un comportamento non corretto del server deve essere rilevato
\end{itemize}

\section{\textit{Selective-Encryption} e \textit{Over-Encryption}}
\subsection{Selective Encryption}
Utenti diversi potrebbero necessitare di viste diverse dei dati nel cloud

$\rightarrow$ \textbf{Selective Encryption:} la politica di autorizzazione definita dal proprietario dei dati 
viene tradotta in una politica di encryption equivalente

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/encryption/selective.png}
\end{figure}

\textit{Desiderata:}
\begin{itemize}
    \item i dati stessi dovrebbero regolare i controlli di accesso 
    \item dovrebbero essere usate chiavi differenti per criptare i dati 
    \item l'autorizzazione di accesso a una risorsa viene tradotta nella \textbf{conoscenza della chiave} con cui la risorsa è criptata 
    \item ad ogni utente vengono comunicate le chiavi per decriptare i dati a cui ha diritto di accesso
\end{itemize}

\subsubsection{Politiche di Autorizzazione}
Il \textit{data owner} definisce delle politiche di autorizzazione per regolare l'accesso ai dati.

\begin{itemize}
    \item Una politica di autorizzazione $\mathcal{A}$ è un set di permessi della forma $\left\langle user, resource \right\rangle$
    
    \noindent Può essere rappresentata sotto forma di:
    \begin{itemize}
        \item matrice 
        \item grafo diretto bipartito
    \end{itemize}
    \item L'idea è che diverse autorizzazioni di accesso ai dati implicano diverse chiave per criptare 
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/encryption/auth-policy.png}
\end{figure}

\subsubsection{Politica di Encryption}
La \textit{politica di autorizzazione} definita dal data owner viene tradotta
in una \textit{politica di encyption} equivalente.

\noindent Due possibili soluzioni:
\begin{itemize}
    \item criptare ogni risorsa con una chiave diversa e dare all'utente le chiavi 
    che decriptano le risorse a cui ha accesso 

    \textcolor{red}{\textbf{-}} l'utente deve gestire tante chiavi quante sono le risorse a cui ha accesso
    \item usare un \textbf{metodo di derivazione delle chiavi} per permettere di derivare dalla propria chiave utente 
    tutte le chiavi a cui hanno accesso 

    \textcolor{darkgreen}{+} ad ogni utente viene rilasciata una sola chiave
\end{itemize}

\subsubsection{Metodi di Derivazione delle Chiavi}
\begin{itemize}
    \item Basata sulla definizione di una \textbf{gerarchia di derivazione delle chiavi} $(\mathcal{K}, \leq)$
    \begin{itemize}
        \item $\mathcal{K}$ è il set di chiavi 
        \item $\leq$ è la relazione d'ordine parziale definita su $\mathcal{K}$
    \end{itemize}
    \item $(\mathcal{K}, \leq)$ può essere rappresentata come un grafo con un vertice per ogni $x \in \mathcal{K}$ e un percorso da $x$ a $y$ sse $y \leq x$
\end{itemize}

\subsubsection{Metodi di Derivazione delle Chiavi basati su Token}
\begin{itemize}
    \item Le chiavi sono assegnate arbitrariamente ai vertici 
    \item Una label $l_i$ (pubblica) viene assegnata a ciascuna chiave $k_i$
    \item Un token $t_{i,j}$ (pubblico) viene associato ad ogni arco nella gerarchia
    \item Dato un arco $(k_i, k_j)$, il token $t_{i,j}$ viene calcolato come $k_j \oplus h(k_i, l_j)$, dove:
    \begin{itemize}
        \item $\oplus$ è l'operatore \texttt{xor}
        \item $h$ è una funzione di hash sicura
    \end{itemize}
    \item \textcolor{darkgreen}{\textbf{+}} i token sono pubblici e permettono agli utenti di derivare più chiavi, ma dovendosi preoccupare solo di una 
    \item \textcolor{darkgreen}{\textbf{+}} possono essere storati su un server così che ogni utente vi può accedere
\end{itemize}

\noindent Le relazioni delle chiavi tramite token possono essere rappresentate con un grafo:
\begin{itemize}
    \item un vertice per ogni coppia $\left\langle k, l \right\rangle$, dove $k \in \mathcal{K}$ è una chiave e $l \in \mathcal{L}$ è l'etichetta associata 
    \item un arco dal vertice $\left\langle k_i, l_i \right\rangle$ a $\left\langle k_j, l_j \right\rangle$ se esiste un token $t_{i,j} \in \mathcal{T}$ che permette la derivazione di $k_j$ a partire da $k_i$
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{images/encryption/token-based-ex.png}
\end{figure}


\noindent Traduzione della politica di autorizzazione in una di encryption:
\begin{itemize}
    \item \textit{Desiderata:}
    \begin{itemize}
        \item ad ogni utente viene rilasciata una sola chiave 
        \item le risorse vengono criptate una sola volta con una sola chiave 
    \end{itemize}
    \item Una funzione $\phi : \mathcal{U} \cup \mathcal{R} \rightarrow \mathcal{L}$ che descrive:
    \begin{itemize}
        \item l'associazione tra un utente la (etichetta della) sua chiave
        \item l'associazione tra una risorsa e la (etichetta della) chiave usata per criptarla
    \end{itemize}
\end{itemize}

\subsubsection{Definzione Formale della Politica Crittografica}
Una \textbf{politica di encryption} su utenti $\mathcal{U}$ e risorse $\mathcal{R}$, denotata come $\mathcal{E}$,
è una 6-tupla $\left\langle \mathcal{U, R, K, L, \phi, T} \right\rangle$, dove:
\begin{itemize}
    \item $\mathcal{K}$ è il set di chiavi del sistema e $\mathcal{L}$ l'insieme delle chiavi corrispondenti
    \item $\phi$ è la funzione di assegnamento delle chiavi e schema crittografico 
    \item $\mathcal{T}$ è il set di token definiti su $\mathcal{K}$ e $\mathcal{L}$
\end{itemize}

\noindent La politica di encryption può essere rappresentata come un grafo estendo quello di chiavi 
e token per includere:
\begin{itemize}
    \item un vertice per ogni utente e ogni risorsa 
    \item un arco da ogni vertice utente $u$ a $\left\langle k, l \right\rangle$ tale che $\phi(u)=l$
    \item un arco da ogni vertice $\left\langle k, l \right\rangle$ a ogni vertice risorsa $r$ tale che $\phi(r)=l$
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/encryption/encryption-policy-graph.png}
\end{figure}
 
\subsubsection{Politica di Trasformazione}
\textbf{Obiettivo:} trasformare una politica di autorizzazione $\mathcal{A}$
in una politica di encryption $\mathcal{E}$ \textbf{equivalente}.

\noindent $\mathcal{A}$ e $\mathcal{E}$ si dicono equivalenti se
garantiscono gli stessi accessi.

\begin{itemize}
    \item \textbf{Soluzione nativa}
    \begin{itemize}
        \item ad ogni utente viene associata una chiave 
        \item ogni risorsa viene criptata con una chiave
        \item per ogni permesso $\left\langle u,r \right\rangle$ viene generato un token $t_{u,r}$
    \end{itemize}

    $\rightarrow$ produrre e gestire un token per ogni singolo permesso non è realizzabile
    \item $\rightarrow$ \textbf{Si sfruttano i gruppi di utente}
    \begin{itemize}
        \item si raggruppano gli utenti con gli stessi privilegi
        \item si cripta ogni risorsa con la chiave associata al set di utenti che può accedervi
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item È possibile creare un grafo sfruttando la gerarchia tra insiemi di utenti, indotta
    dalla relazione d'ordine parziale di inclusione di insieme ($\subseteq$)
    \item \textbf{Osservazione:} i gruppi che non corrispondono a nessun accesso non hanno bisogno di una chiave 
    \item $\rightarrow$ \textbf{Obiettivo:} computare una politica di encryption minima, equivalente a una politica di autorizzazione data, 
    che minimizza il numero di token gestiti dal server
\end{itemize}

\subsubsection{Costruzione di un grafo per chiavi e token}
Partendo da un politica di autorizzazione $\mathcal{A}$:
\begin{enumerate}
    \item \textbf{Inizializzazione:} si crea un vertice (chiave) per ogni utente e gruppi di utenti (\textit{acl})
    \item \textbf{Covering} minimo; mi fa in modo che ciascun utente possa raggiungere le sue chiavi
    \item \textbf{Fattorizzazione} di antenati comuni (se ho $n$ nodi da una parte e $m$ dall'altra, mettendo un \textit{hub} in mezzo passo da $n*m$ a $n+m$)
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.91\linewidth]{images/encryption/graph.png}
\end{figure}

\newpage
\begin{itemize}
    \item gli utenti riceveranno:
    \begin{itemize}
        \item $A = \left\langle k_1, l_1 \right\rangle$
        \item $B = \left\langle k_2, l_2 \right\rangle$
        \item $C = \left\langle k_3, l_3 \right\rangle$
        \item $D = \left\langle k_4, l_4 \right\rangle$
    \end{itemize}

    tutto il resto è sul server
    \item la funzione $\phi$ mi dice rispettivamente quali chiavi hanno gli utenti e quali chiavi sono associate alle risorse,
    facendo riferimento alle \textit{label}
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.92\linewidth]{images/encryption/graph2.png}
\end{figure}

\noindent Quando le autorizzazioni cambiano dinamicamente, il data owner deve:
\begin{itemize}
    \item scaricare la risorsa dal server 
    \item creare una nuova chiave 
    \item decriptare la risorsa con la vecchia chiave 
    \item criptare la risorsa con la nuova chiave 
    \item upload della risorsa e comunicare l'update 
    
    $\rightarrow$ Non efficiente;

    \item Possibile soluzione \textbf{over-encryption}
\end{itemize}

\subsection{Over-Encryption}
Le risorse vengono criptate due volte:
\begin{itemize}
    \item dall'\textit{owner}, con una chiave condivisa a tutti gli utenti e sconosciuta dal server (\textbf{Base Encryption Layer - BEL})
    \item dal \textit{server}, con una chiave condivisa agli utenti autorizzati (\textbf{Surface Encryption Layer - SEL})
    
    $\rightarrow$ per accedere a una risorsa un utente deve conoscere sia la chiave BEL che SEL
\end{itemize}

\subsubsection{BEL}
A livello BEL distinguiamo due tipi di chiavi: chiavi di \textbf{accesso} $k_a$ e di derivazione $k$
\begin{itemize}
    \item ogni nodo viene associato ad una coppia di chiavi $(k, k_a)$ dove $k_a=h(k)$ ($h$ funzione hash sicura \textit{one-way}) e 
    ad una coppia di labels $(l, l_a)$
    \item la chiave $k$ e la label $l$ sono usate per la derivazione 
    \item la chiave $k_a$ e la label $l_a$ sono usate per criptare le risorse associate al nodo 
    \item la distinzione delle chiavi separa i due ruoli: derivazione delle chiavi e accesso alle risorse
\end{itemize}

\subsubsection{SEL}
A livello SEL viene fatta una politica di encryption come mostrato precedentemente; ci 
si può dividere in due scenari:
\begin{itemize}
    \item \textbf{Full\underbar{}SEL:} inizia da un SEL identico al BEL e tiene il SEL sempre aggiornato per rispecchiare la politica corrente
    \item \textbf{Delta\underbar{}SEL:} inizia da un SEL vuoto e aggiunge elementi man mano che la politica evolve, in modo tale che la coppia BEL SEL rispecchi la politica
\end{itemize}

\newpage
L'evoluzione di BEL e SEL è gestita da:
\begin{itemize}
    \item procedura \textbf{over-encrypt} che regola il processo di update facendo over-encryption delle risorse a livello SEL
    
    \textit{chiedo aiuto al server per andare a coprire qualcosa}
    \item procedure \textbf{grant} e \textbf{revoke} per gestire i privilegi
    
    \textit{l"andare a coprire qualcosa" mi serve sia in operazioni di grant che di revoke}

    \textit{\textbf{grant}} $\rightarrow$ \textit{coprire delle risorse che altrimenti resterebbero scoperte}
    
    \textbf{\textit{revoke}} $\rightarrow$ \textit{coprire per non rendere più accessibile}
\end{itemize}

\subsection{Collusione}
La collusione si verifica quando due entità, unendo le loro conoscenze, acquisicono conoscenza a cui 
prima nessuna delle due aveva accesso.

\noindent Ci può essere collusione tra utenti o con il server; dipende dalla visione che gli utenti hanno delle risorse.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/encryption/views.png}
\end{figure}

\chapter{Fragmentation e Encryption}
L'encryption rende la valutazione delle query e l'esecuzione delle applicazioni 
più costosa e non sempre possibile.

Spesso ciò che è sensibile è l'\textbf{associazione} tra valori di attributi diversi, 
piuttosto che i valori stessi.

$\rightarrow$ si proteggono le associazioni \textbf{spezzandole}, piuttosto che criptando

\subsubsection{Constraint di confidenzialità}
\begin{itemize}
    \item \textbf{Attributi sensibili:} il \textbf{valore} di alcuni attributi potrebbe essere considerato sensibile e non dovrebbe essere visibile 
    
    $\rightarrow$ \textit{singleton constraint}
    \item \textbf{Associazioni sensibili:} l'\textbf{associazione} dei valori di attributi dati è sensibile e non dovrebbe essere sensibile 
    
    $\rightarrow$ \textit{non-singleton constraint}
\end{itemize}

\section{Coppia di server non-comunicanti}
I vincoli di riservatezza sono rispettati dividendo le informazioni
su \textbf{due server indipendenti che non comunicano}.
\begin{itemize}
    \item le associazioni sensibili sono protette distribuendo i valori su 
    i due server 
    \item l'encryption viene usata per coprire i valori che non possono stare su nessuno dei due server (constraint oppure 
    esporrebbe almeno una associazione sensibile)
\end{itemize}

I constraint di confidenzialità $\mathcal{C}$ definiti su una relazione 
$\mathcal{R}$ sono applicati scomponendo $\mathcal{R}$ come $\left\langle R_1, R_2, E \right\rangle$, dove:
\begin{itemize}
    \item $R_1$ e $R_2$ hanno un \textit{tuple ID} per garantire un join senza perdita di informazioni
    \item $R_1 \cup R_2 = R $
    \item $E$ è il set di attributi criptati, con $E \subset R_1, E \subset R_2$
    \item Nessun costraint di confidenzialità può essere contenuto insieme in chiaro  
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{images/encryption-fragmentation/couple-frag.png}
\end{figure}

\subsection{Esecuzione delle query}
Per rispondere alle query sarà necessario interrogare entrambi i server; è possibile farlo 
in due modi:
\begin{itemize}
    \item si mandano delle \textit{sub-queries} a \textcolor{orange}{$S_1$} e \textcolor{blue}{$S_2$} in parallelo, per poi 
    joinare i risultati sul client 
    \item si manda solo una delle \textit{sub-queries}, ad esempio a \textcolor{orange}{$S_1$}; il \textit{tuple ID} del risultato 
    di \textcolor{orange}{$S_1$} è usato poi per fare un semi-join con il risultato della query di \textcolor{blue}{$S_2$}
\end{itemize}

\subsection{Identificare la scomposizione ottimale}
Si utilizza una \textbf{matrice di affinità:} indica quanto spesso due attributi 
sono acceduti insieme e la frequenza delle query.

\noindent Matrice di affinità $M$:
\begin{itemize}
    \item $M_{i,j}$: costo di mettere attributi $i$ e $j$ in chiaro in frammenti diversi 
    \item $M_{i,i}$: costo di criptare attributo $i$ (e metterlo in entrambi i frammenti)
    \item \textbf{Obiettivo:} Minimizzare $\sum M_{i,j} + \sum M_{i,i}$ (la somma delle affinità e criptazione)
\end{itemize}

\newpage
\section{Frammenti non comunicanti multipli}
L'assunzione di avere (solo) due server non comunicanti:
\begin{itemize}
    \item \textcolor{red}{\textbf{-}} difficile da realizzare 
    \item \textcolor{red}{\textbf{-}} limita il numero di associazioni che si possono risolvere solo con la frammentazione
\end{itemize}

$\rightarrow$ si utilizzano frammenti non comunicanti multipli

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/encryption-fragmentation/multi-frag.png}
\end{figure}

\begin{itemize}
    \item Una frammentazione di $\mathcal{R}$ è un set di frammenti 
    $\mathcal{F} = \{ F_1, \dots, F_m\}$ dove $F_i \subset R$ 
    \item Una frammentazione $\mathcal{F}$ soddisfa correttamente un set constraint
    di confidenzialità $\mathcal{C}$ se:
    \begin{itemize}
        \item ogni frammento soddisfa i constraint
        \item i frammenti non hanno attributi in comune
    \end{itemize}
    \item Ogni frammento viene mappato in un \textit{frammento fisico} contenente:
    \begin{itemize}
        \item i suoi attributi in chiaro
        \item tutti gli altri attributi criptati (per ogni criptazione viene applicato un \textit{salt})
    \end{itemize}
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/encryption-fragmentation/multi-ex.png}
\end{figure}

\newpage
\subsection{Esecuzione delle query}
Dato che ogni frammento contiene tutti gli attributi, per rispondere a una query 
basta accedere soltanto a uno; se la query coinvolge un attributo criptato, 
potrebbe essere necessario fare delle query aggiuntive sul client.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/encryption-fragmentation/multi-frag-query.png}
\end{figure}

\newpage
\subsection{Criteri di ottimizzazione}
L'obiettivo è trovare una frammentazione che renda l'esecuzione delle query efficiente.

\noindent Ci sono diversi criteri di ottimizzazione:
\begin{itemize}
    \item \textbf{Numero di frammenti minimo}
    \item \textbf{Affinità tra attributi}
    \item \textbf{Query workload} (minimizzare il costo dell'esecuzione delle query)
\end{itemize}

\noindent Ciascuno di questi criteri obbedisce alla \textbf{visibilità massima:}
\begin{itemize}
    \item solo gli attributi che appaiono in \textit{singleton constraint} vengono criptati 
    \item tutti gli attributi che non sono sensibili appaiono in chiaro in un frammento
\end{itemize}

\subsubsection{Minimo numero di frammenti}
\begin{itemize}
    \item Si definisce una nozione di minimalità per computare in modo efficiente la soluzione
    \begin{itemize}
        \item $\mathcal{F}$ è minimale se prendendo due frammenti qualsiasi da $\mathcal{F}$ e unendoli si viola almeno un constraint di confidenzialità
    \end{itemize}
    \item Iterativamente si seleziona un attributo con il numero massimo di constraint non risolti e lo si inserisce 
    in un frammento esistentente se non viene violato alcun constraint; se ne crea uno nuovo altrimenti
\end{itemize}

\subsubsection{Massima affinità tra attributi}
Idea:
\begin{itemize}
    \item preservare le associazioni tra alcuni attributi 
    \item \textbf{matrice di affinità} per rappresentare il vantaggio di avere una coppia 
    di attributi nello stesso frammento
\end{itemize}

Obiettivo: 
\begin{itemize}
    \item Computare una frammentazione corretta con affinità massima 
    \item Iterativamente si combinano i frammenti che hanno l'affinità massima e che non violano alcun constraint
\end{itemize}

\chapter{Frammentazione}
L'idea di base è:
\begin{itemize}
    \item \textcolor{red}{\textbf{-}} la cifratura rende l'esecuzione delle query più costosa e non sempre possibile 
    \item \textcolor{red}{\textbf{-}} la cifratura comporta un sovraccarico per la gestione delle chiavi
    \item $\rightarrow$ si abbandona la cifratura, per coinvolgere l'\textbf{owner come una parte fidata che mantiene una quantità limitata di dati}
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/fragmentation/intro.png}
\end{figure}

Dati uno schema relazionale $R$ e dei constraint $\mathcal{C}$ su di esso, si 
determina una frammentazione $\mathcal{F} = \left\langle F_O, F_S \right\rangle$, dove lo storage di
$F_O$ è affidato all'owner e quello di $F_S$ al server, e:
\begin{itemize}
    \item $F_O \cup F_S = R$ (\textbf{completezza})
    \item $\forall c \in \mathcal{C}, c \notin F_S$ (\textbf{riservatezza})
    \item $F_O \cap F_S = \emptyset$ (\textbf{non ridondanza}, non è essenziale a fini di sicurezza)
\end{itemize}

A livello fisico i frammenti $F_O$ e $F_S$ hanno un attributo in comune (\textit{tuple ID} oppure attributo-chiave) 
per garantire un join senza perdita di informazioni. 

\section{Valutazione delle query}
Le query formulate su $R$ devono essere tradotte in \textbf{query equivalenti} su 
$F_O$ e/o $F_S$

$\rightarrow$ \texttt{SELECT $A$ FROM $R$ WHERE $C$}, dove $C$ è una congiunzione 
di condizioni, che possono essere del tipo:
\begin{itemize}
    \item $C_O$: congiunzioni che involvono solo attributi storati nel client 
    \item $C_S$ congiunzioni che involvono solo attributi storati nel server 
    \item $C_{SO}$ congiunzioni che involvono attributi storati sia nel client che nel server 
\end{itemize} 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\linewidth]{images/fragmentation/query-ex.png}
\end{figure}


\subsection{Strategia Server-Client}
\begin{enumerate}
    \item \textcolor{blue}{\textbf{Server:}} valuta $C_S$ e ritorna il risultato al client 
    \item \textcolor{orange}{\textbf{Client:}} riceve il risultato dal server con $F_O$ (frammento dell'owner)
    \item \textcolor{orange}{\textbf{Client:}} valuta $C_O$ e $C_SO$ dopo aver fatto il join 
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\linewidth]{images/fragmentation/sc-1.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{images/fragmentation/sc-2.png}
\end{figure}

\subsection{Strategia Client-Server}
\begin{enumerate}
    \item \textcolor{orange}{\textbf{Client:}} valuta $C_O$ e manda i \textit{tuple ID} al server 
    \item \textcolor{blue}{\textbf{Server:}} fa il join dell'input con $F_S$, valuta $C_S$, e ritorna il risultato al client 
    \item \textcolor{orange}{\textbf{Client:}} fa il join del risultato con $F_O$ e valuta $C_SO$
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{images/fragmentation/cs.png}
\end{figure}

\subsection{Strategie a confronto}
\begin{itemize}
    \item se il server \textbf{conosce o può inferire la query}, allora la strategia Client-Server rilascia informazioni
    
    $\rightarrow$ il server può inferire che alcune tuple sono associate a valori che soddisfano $C_O$
    \item se il server \textbf{non conosce e non può inferire la query}, allora entrambe le strategie sono sicure 
    
    $\rightarrow$ si sceglie quella più performante, valutando per prime le condizioni più selettive
\end{itemize}

\newpage
\section{Frammentazione minima}
\begin{itemize}
    \item L'obiettivo è \textbf{minimizzare il carico di lavoro dell'owner}, gestendo $F_O$
    \item Si stabilisce una funzione peso $w$ che prende una coppia $\left\langle F_O, F_S \right\rangle$ come input
    e ritorna il carico di lavoro dell'owner 
    \item Una frammentazione $\mathcal{F} = \left\langle F_O, F_S \right\rangle$ si dice minimale sse:
    \begin{itemize}
        \item $\mathcal{F}$ è corretta (soddisfa le proprietà di correttezza, confidenzialità e non-ridondanza)
        \item $ \not\exists \mathcal{F}'$ tale che $w(\mathcal{F}') < w(\mathcal{F})$ e $\mathcal{F}'$ è corretto 
    \end{itemize}
\end{itemize}

\subsection{Metriche per la frammentazione}
Possono essere usate diverse metriche per dividere gli attributi tra $F_O$ e $F_S$, 
per minimizzare:
\begin{itemize}
    \item \textbf{Storage}
    \begin{itemize}
        \item Numero di attributi in $F_O$ (\textit{\textbf{Min-Attr}}):
        
        $\rightarrow w_a(\mathcal{F}) = |F_O|$

        \item Dimensione degli attributi in $F_O$ (\textit{\textbf{Min-Size}}):
        
        $\rightarrow w_s(\mathcal{F}) = \sum_{A \in F_O} size(A)$
    \end{itemize}
    \item \textbf{Computazione/Traffico}
    \begin{itemize}
        \item Numero di query in cui l'owner viene coinvolto (\textit{\textbf{Min-Query}}):
        
        Si definisce un \textit{query workload profile}:

        $\mathcal{Q} = \{(q_1, freq(q_1), Attr(q_1), \dots, q_n, freq(q_n), Attr(q_n)) \}$, con:
        \begin{itemize}
            \item $q_1, \dots, q_n$ query da eseguire 
            \item $freq(q_i)$ frequenza attesa di $q_i$
            \item $Attr(q_i)$ attributi che compaiono nella clausola \texttt{WHERE} di $q_i$
        \end{itemize}

        $\rightarrow w_q(\mathcal{F}) = \sum_{q \in \mathcal{Q}} freq(q)$ t.c. $Attr(q) \cap F_O \neq \emptyset$

        \item Numero di condizioni nelle query in cui è necessario coinvolgere l'owner (\textit{\textbf{Min-Cond}}):
        
        Si definisce un \textit{query workload profile}:

        $\mathcal{Q} = \{(q_1, freq(q_1), Cond(q_1), \dots, q_n, freq(q_n), Cond(q_n)) \}$, con:
        \begin{itemize}
            \item $q_1, \dots, q_n$ query da eseguire 
            \item $freq(q_i)$ frequenza attesa di $q_i$
            \item $Cond(q_i)$ condizioni che compaiono nella clausola \texttt{WHERE} di $q_i$
        \end{itemize}

        $\rightarrow w_c(\mathcal{F}) = \sum_{c \in Cond(\mathcal{Q})} freq(c)$ t.c. $c \cap F_O \neq \emptyset$


    \end{itemize}
\end{itemize}

\subsection{Modellizzazione del problema di mininimzzazione}
Tutti i problemi di minimizzazione mirano ad identificare 
un \textit{\textbf{hitting set}}; metriche differenti corrispondo a criteri 
differenti secondo cui l'\textit{hitting set} deve essere minimizzato.

\noindent Tutti i criteri sono rappresentati in modo uniforme 
con il seguente modello:
\begin{itemize}
    \item \textbf{target set:} elementi (attributi, query, condizioni) su cui è definito il problema di minimizzazione
    \item \textbf{funzione peso:} funzione che associa un peso a ciascun elemento
    \item \textbf{peso di un set di attributi:} somma dei pesi dei target che intersecano con il set
\end{itemize}

$\rightarrow$ si vuole computare un hitting set con peso minimo

\subsection{Algoritmo Euristico}
\begin{itemize}
    \item \textbf{Input:}
    \begin{itemize}
        \item $\mathcal{A}$: set di attributi che non appaiono in \textit{singleton constraint} 
        \item $\mathcal{C}$: set di constraint ben definiti 
        \item $\mathcal{T}$: set di target 
        \item $w$: funzione peso definita su $\mathcal{T}$
    \end{itemize}
    \item \textbf{Output:}
    \begin{itemize}
        \item $\mathcal{H}$: set di attributi che, uniti a quelli che appaiono in \textit{singleton constraint}, formano $F_O$
        \item $F_S$ computato come $R / F_S$
    \end{itemize}
    \item \textbf{Struttura Dati:}
    \textit{Priority-queue} $PQ$ con un elemento $E$ per ogni attributo:
    \begin{itemize}
        \item $E.A$: attributo 
        \item $E.C$: puntatore a constraint non soddisfatti che contengono $E.A$
        \item $E.T$: puntatore ai target che non intersecano $\mathcal{H}$ che contengono $E.A$
        \item $E.n_c$: numero di constraint puntati da $E:C$
        \item $E.w$. peso totale dei target puntati da $E.T$
    \end{itemize}

    $\rightarrow$ la priorità è dettata da $E.w / E.n_c$, ovvero il miglior rapporto \textit{costo / numero di vincoli risolti}
\end{itemize}

\newpage
\subsubsection{Procedura}
\begin{itemize}
    \item \texttt{\textbf{while}} $PQ \neq \emptyset$ e $\exists E \in PQ$ t.c. $E.n_c \neq 0$
    \begin{itemize}
        \item estrai da $PQ$ elemento $E$ con $E.w/E.n_c$ minimo 
        \item inserisci $E.A$ in $\mathcal{H}$
        \item $\forall c$ puntato da $E.C$, rimuovi i puntatori a $c$ da ogni elemento $E'$, ed aggiorna $E'.n_c$ 
        \item $\forall t$ puntato da $E.T$, rimuovi i puntatori a $t$ da ogni elemento $E'$, ed aggiorna $E'.w$
        \item aggiusta $PQ$ secondo i nuovi $E.w / E.n_c$
    \end{itemize}
    \item \texttt{\textbf{for}} $A \in \mathcal{H}$
    \begin{itemize}
        \item se $\mathcal{H} / A$ è un \textit{hitting set} per $\mathcal{C}$, 
        allora rimuovi $A$ da $\mathcal{H}$
    \end{itemize}
\end{itemize}

\newpage
\section{Frammentazione e inferenza}
La frammentazione assume che gli attributi siano tra loro indipendenti;
in caso di dipendenza tra attributi, potrebbe verificarsi l'esposizione indiretta di attributi/associazioni sensibili.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/fragmentation/inference1.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/fragmentation/inference2.png}
\end{figure}

\textit{Avere attributi in comune significa essere linkabili; ma non è vero 
che essere linkabili significhi per forza dire avere attributi in comune.}

\noindent I frammenti non dovrebbe contenere attributi/associazioni sensibili 
\textbf{né direttamente che indirettamente.}

\chapter{Pubblicazione di Associazioni Offuscate}

\section{Anonimizzazione di Grafo Bipartito}
Si \textit{maschera} il mapping tra entità e nodi del grafo, 
conservando la struttura del grafo (e quindi delle relazioni).

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{images/publ-obf-ass/grafo-bipartito.png}
\end{figure}

\noindent Pubblicando una versione anonimizzata del grafo bipartito 
si può rispondere a diverse query:
\begin{itemize}
    \item \textbf{Tipo 0 - Struttura del grafo}
    
    \textit{Qual è il numero medio di prodotti comprati?}
    \item \textbf{Tipo 1 - Predicati su attributi di un solo lato}
    
    \textit{Qual è il numero medio di prodotti comprati da clienti del NJ?}
    \item \textbf{Tipo 2 - Predicati su attributi di entrambi i lati}
    
    \textit{Qual è il numero medio di prodotti OTC acquistati dai clienti del NJ?}
\end{itemize}

\noindent La privacy delle associazioni viene rispettata.

\subsection{\textit{(k, l)} grouping}
L'idea è quella di preservare la struttura del grafo mappando 
le singole entità a nodi:

$\rightarrow \textbf{(k, l)}$ \textbf{grouping di un grafo bipartito} $\textbf{G=(V,W,E)}$
\begin{itemize}
    \item Si partiziona $V$ ($W$, rispettivamente) in sottoinsiemi che non intersecano tra loro di 
    dimensione $\leq k$ ($l$, rispettivamente)
    \item Si pubblicano gli archi $E'$, isomorfi ad $E$, dove la mappatura da $E$ a $E'$ è 
    anonimizzata grazie alle partizioni di $V$ e $W$
\end{itemize} 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.79\linewidth]{images/publ-obf-ass/k-l1.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.99\linewidth]{images/publ-obf-ass/k-l2.png}
\end{figure}

Per fare dei \textbf{raggruppamenti sicuri}, i nodi nello stesso gruppo di $V$ 
non dovrebbero essere connessi a uno stesso nodo di $W$.

\section{Frammenti e \textit{Loose Associations}}
Per incrementare l'utilità delle informazioni pubblicate, 
si possono fare delle associazioni tra gruppi di valori.

\subsection{Frammentazione Corretta e Minima}
\begin{itemize}
    \item Una frammentazione è \textbf{corretta} se:
    \begin{itemize}
        \item ogni constraint di confidenzialità è soddisfatto da \textbf{tutti} i frammenti 
        \item ogni requisito di visibilità è soddisfatto da \textbf{almeno} un frammento
        \item i frammenti non hanno attributi in comune
    \end{itemize}
    \item Una frammentazione è \textbf{minimale} se:
    \begin{itemize}
        \item il numero di frammenti è \textbf{minimo}
    \end{itemize}
\end{itemize}

\subsection{\textit{Loose Associations}}
Dati due frammenti $F_l$ e $F_r$, una \textit{loose association} tra $F_l$ e $F_r$:
\begin{itemize}
    \item partiziona le tuple dei frammenti in \textbf{gruppi}
    \item dà informazioni sulle associazioni a \textbf{livello di gruppo}
    \item \textbf{non permette di ricostruire} esattamente le associazioni originali tra tuple 
    \item aumenta l'utilità dei dati pubblicati 
\end{itemize} 

\subsection{Grouping}
\begin{itemize}
    \item Data l'istanza $f_i$ di un frammento $F_i$, un $k$-grouping partiziona le tuple in gruppi di dimensione
    $\geq k$
    \item Un $k-grouping$ è minimale se massimizza il numero di gruppi
    \item La notazione $(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping denota i gruppi su \textcolor{orange}{$f_l$} e \textcolor{blue}{$f_r$}
    \item $(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping è minimale se sia \textcolor{orange}{$k_l$}-grouping che \textcolor{blue}{$k_r$}-grouping sono minimali
\end{itemize}

\newpage
\subsubsection{Esempio - minimal (2,2)-grouping}
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{images/publ-obf-ass/minimal-grouping.png}
\end{figure}

\subsubsection{Associazione tra Gruppi}
$(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping induce una 
associazione $A$ tra gruppi di \textcolor{orange}{$f_l$} e \textcolor{blue}{$f_r$};

\noindent definiamo una associazione $A$ come un set di coppie di \textit{identificatori di gruppo} tale che:

\begin{itemize}
    \item $A$ ha la stessa cardinalità della relazione originale
    \item ogni tupla nella relazione originale è mappata in modo biietivo ad una coppia $(\textcolor{orange}{l}, \textcolor{blue}{r})$
    con $\textcolor{orange}{l} \in \textcolor{orange}{f_l}$ e $\textcolor{blue}{r} \in \textcolor{blue}{f_r}$
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/publ-obf-ass/group-ass1.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/publ-obf-ass/group-ass2.png}
\end{figure}

\newpage
\subsection{\textit{k}-loose association}
Una associazione tra gruppi si dice \textbf{$k$-loose} se ogni tupla corrisponde indistintamente ad almeno $k$ associazioni tra tuple nei frammenti.

\subsection{\textit{Alikeness}}
Due tuple sono \textit{\textbf{alike}} rispetto a un constraint
di confidenzialità $c$, denotata come $\textcolor{orange}{l_i} \simeq_c \textcolor{orange}{l_j}$ se:
\begin{itemize}
    \item $c$ è coperto da $\textcolor{orange}{F_l} \cup \textcolor{blue}{F_r}$
    \item l'intersezione di $c$ sulle due tuple ha uguale valore
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{images/publ-obf-ass/alike.png}
\end{figure}
 

\newpage
\subsection{Proprietà di Eterogeneità}
C'è una relazione tra $\textcolor{orange}{k_l}, \textcolor{blue}{k_r}$ e 
il grado di $k$-looseness:
\begin{itemize}
    \item un $(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping può indurre 
    una $k$-loose association con al massimo $k = \textcolor{orange}{k_l}*\textcolor{blue}{k_r}$
    \item il valore $k \leq \textcolor{orange}{k_l}*\textcolor{blue}{k_r}$ dipende da come sono definiti i gruppi
    \item Se un $(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping rispetta le proprietà di eterogeneità, 
    la relazione tra gruppi sarà $k$-loose con $k = \textcolor{orange}{k_l}*\textcolor{blue}{k_r}$
\end{itemize}

\subsubsection{Eterogeneità dei gruppi}
Nessun gruppo può contenere tuple che sono \textit{alike} 

$\rightarrow$ assicura diversità tra le tuple all'interno dei gruppi

\subsubsection{Eterogeneità delle associazioni}
Nessun gruppo può essere associato due volte allo stesso gruppo.

$\rightarrow$ assicura che per ogni tupla della relazione originale, ci siano almeno 
$\textcolor{orange}{k_l} * \textcolor{blue}{k_r}$ coppie a cui potrebbe corrispondere

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\linewidth]{images/publ-obf-ass/ass-hetero.png}
\end{figure}

\newpage
\subsubsection{Eterogeneità profonda}
Nessun gruppo può essere associato a due gruppi che contengono tuple \textit{alike}.

$\rightarrow$ assicura che tutte le $\textcolor{orange}{k_l} * \textcolor{blue}{k_r}$ 
a cui ogni tupla potrebbe corrispondere abbiano valori diversi (per quelli coinvolti nei constraint)

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{images/publ-obf-ass/deep-hetero.png}
\end{figure}

\subsection{\textit{Flat grouping} vs \textit{Sparse grouping}}
Un $(\textcolor{orange}{k_l}, \textcolor{blue}{k_r})$-grouping si dice:
\begin{itemize}
    \item \textit{piatto} se uno tra $\textcolor{orange}{k_l}$ o $\textcolor{blue}{k_r}$ è uguale a 1
    \item \textit{sparso} se sia $\textcolor{orange}{k_l}$ che $\textcolor{blue}{k_r}$ sono diveri da 1
\end{itemize}

\subsection{Privacy vs Utilità}
\begin{itemize}
    \item La pubblicazione delle \textit{loose associations} incrementa l'\textbf{utilità}
    dei dati; permette di valutare le query in modo più preciso rispetto a se solamente 
    i frammenti fossero pubblicati 
    \item Una maggiore utilità corrisponde anche ad una maggiore \textbf{esposizione} (meno sicurezza)
\end{itemize}














\end{document}