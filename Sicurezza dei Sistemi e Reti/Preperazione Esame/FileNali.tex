\documentclass{report}
\usepackage{graphicx} % Required for inserting images
\usepackage[italian]{babel}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{float}
\usepackage{soul}
\usepackage{listings} % Per evidenziare il codice

\definecolor{lightgray}{rgb}{0.9,0.9,0.9} % Definizione colore sfondo
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}

\lstset{
    backgroundcolor=\color{lightgray}, % Sfondo grigio
    basicstyle=\ttfamily, % Font monospaziato
    % frame=single, % Bordo attorno al codice
    tabsize=4, % Dimensione tabulazione
    breaklines=true, % Permette di andare a capo automaticamente
    numbers = left,
    numberstyle=\small\color{gray}
}

\title{\huge\textbf{{Sicurezza dei Sistemi e delle Reti}}}
\date{File di Nali}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Politiche di Sicurezza}
\section{Definizione Politica di sicurezza}

La \textit{gestione della sicurezza} è un \textit{processo formale} 
per rispondere alle domande:
\begin{itemize}
    \item quali sono i beni da proteggere
    \item quali sono le possibili minacce
    \item come si possono contrastare le minacce 
\end{itemize}

\noindent Questo processo ha natura iterativa, ed è contenuto nella ISO 31000; in 
questa norma viene descritto un \textit{modello per la gestione della sicurezza 
delle informazioni} che comprende le seguenti fasi:
\begin{itemize}
    \item \textbf{Plan:}
    \begin{itemize}
        \item stabilire politiche, processi e procedure di sicurezza
        \item eseguire la valutazione del rischio 
        \item sviluppare un piano di trattamento del rischio 
    \end{itemize}
    \item \textbf{Do:}
    \begin{itemize}
        \item implementare il piano di trattamento del rischio
    \end{itemize}
    \item \textbf{Check:}
    \begin{itemize}
        \item monitorare e mantenere il piano di trattamento del rischio
    \end{itemize}
    \item \textbf{Act:}
    \begin{itemize}
        \item mantenere e migliorare la gestione dei rischi 
        \item risposta ad incidenti, analisi di vulnerabilità e riprendere il ciclo iterativamente
    \end{itemize}
\end{itemize}

\subsection{Definizioni}
\begin{itemize}
    \item \textbf{Rischio:} esprime la possibilità che un attacco causi danni ad una 
    organizzazione
    \item \textbf{Risorsa:} tutto ciò che necessita di essere protetto
    \begin{itemize}
        \item \textit{hw}
        \item \textit{sw}
        \item \textit{reputazione}
    \end{itemize}
    
    \noindent La valutazione di una risorsa viene fatta in base:
    \begin{itemize}
        \item ai costi da sostenere per sostituire la risorsa nel caso non sia più disponibile 
        \item perdita di incassi in caso di attacco 
    \end{itemize}
    \item \textbf{Vulnerabilità:} punti deboli che possono essere sfruttati per causare danni al 
    sistema; possono essere classificate come:
    \begin{itemize}
        \item critico 
        \item moderato 
        \item basso
    \end{itemize}
\end{itemize}

\noindent Definizione per domanda esame: Una politica di sicurezza dei sistemi e delle reti è l'insieme strutturato di regole, requisiti e comportamenti che un'organizzazione definisce affinché i propri sistemi informatici e le proprie infrastrutture di rete applichino in modo coerente misure di protezione contro accessi non autorizzati, abusi, perdite di dati e altri rischi. Essa rappresenta ciò che il sistema deve far rispettare, automatizzando e facendo valere controlli come l'autenticazione, l'autorizzazione, il monitoraggio delle attività e la gestione delle vulnerabilità, allo scopo di garantire la riservatezza, l’integrità e la disponibilità delle informazioni, secondo gli obiettivi stabiliti dall'organizzazione stessa.


\section{Domanda MAC, DAC e RBAC}
\begin{center}
    \textit{definire l'utilizzo delle politiche di sicurezza basate su MAC, DAC e RBAC}
\end{center}
\noindent Gli approcci DAC,MAC e RBAC fanno parte delle politiche di controllo degli accessi e forniscono approcci diversi
a seconda del contesto di applicazione
\subsection{DAC (Discretionary Access Control):}
\noindent Il controllo dell'accesso viene fatto sull' \textbf{identità del soggetto richiedente} e delle \textbf{regole di accesso}.
Definito \textit{discrezionale} poichè un'entità potrebbe avere i privilegi di accessi che le permettono, a sua volta, di concedere l'accesso ad un'altra entità.

\noindent Si può rappresentare mediante una matrice, dove:
\begin{itemize}
    \item le colonne rappresentano i soggetti
    \item le righe gli oggetti
    \item ogni cella specifica i diritti di accesso di quel soggetto a quel determinato oggetto
\end{itemize}


\subsection{MAC (Mandatory Access Control):} 
La politica di controllo degli accesssi MAC, o Mandatory Access Controll si basa sul confronto tra \textbf{etichette di sicurezza} che indicano quanto sono sensibili le risorse
e \textbf{autorizzazioni di sicurezza} che indicano quali entità del sistema sono idonee ad accedere a quali risorse.

\noindent Questa politica è definita \textit{mandatoria} poichè un'entità che possiede l'accesso a una risorsa non può estendere il permesso di acesso a un'altra entità,
può farlo solo l'amministratore di sistema.

\noindent I sistemi MAC si dividono in:
\begin{itemize}
    \item \textbf{Multilevel security systems:} consiste in una struttura verticale di sistemi di sicurezza, agli utent viene assegnato un livello e possono accedere solo a risorse con un livello uguale o inferiore
    \item \textbf{Multilateral security systems:} l'accesso viene assegnato in base a segmenti che formano gruppi costituiti da livelli di sicurezza e parole in codice
    \begin{itemize}
        \item si ottiene una struttura orizzontale, che contiene livelli di sicurezza verticali aggiuntivi
    \end{itemize}
\end{itemize}

\noindent Vantaggi:
\begin{itemize}
    \item molto sicuro, a prova di manomissione
    \item gli utenti non possono fare modifiche
    \item controllo automatizzato
    \item i dati non possono essere modificati senza apposita autorizzazione
\end{itemize}

\noindent Svantaggi:
\begin{itemize}
    \item richiede una pianificazione dettagliata e un lavoro amministrativo
    \item controllo e aggiornamento dei dati di accesso
    \item manutenzione per aggiunta di nuovi dati o utenti e relative modifiche (elevato carico di lavoro per l'amministratore)
\end{itemize}

\subsection{RBAC (Role Based Access Control):}
\noindent Introduce il concetto di \textbf{ruolo}, ovvero una funzione che può essere assiciata a uno o più utenti (gli utenti possono avere più ruoli)
e una \textbf{sessione}, ovvero una mappatura tra utente e un sottoinsieme di ruoli a cui è assegnato.

\noindent I ruoli di un utente possono fornire o meno accesso a determinate risorse.

\noindent Quattro tipi di entità:
\begin{itemize}
    \item \textbf{Utente:} una persona che ha accesso al sistema, ogni individuo ha un ID associato
    \item \textbf{Ruolo:} funzione lavorativa all'interno dell'organizzazione
    \item \textbf{Autorizzazione:} approvazione di una modalità di accesso ad uno o più oggetti
    \item \textbf{Sessione:} mappatura tra utente e un sottoinsieme dei ruoli a cui è assegnato
\end{itemize}

\section{Fare cenni sull'utilizzo di tali politiche nei Sistemi Operativi moderni}
\subsection{Unix security model}
In Linux ci sono tre entità da considerare:
\begin{itemize}
    \item \textbf{Soggetto:} può essere un utente o un processo 
    \item \textbf{Oggetto:} file, cartelle, \dots
    \item \textbf{Operazioni consentite:} lettura, scrittura, esecuzione 
\end{itemize}

\noindent In Unix, ogni utente ha associato un id univoco, detto \textbf{UID}; può appartenere a 
gruppi di utenti, anch'essi identificati da un id univoco detto \textbf{GID}. Tutti gli utenti 
appartenenti ad un gruppo possono condividere tra loro oggetti.

\noindent Ad ogni file è assegnato un unico utente proprietario e un unico gruppo proprietario. L'autorizzazione 
viene concessa mediante una ACL che identifica le operazioni che i soggetti possono fare.

\subsubsection{Processi in Linux}
Ogni processo è isolato dagli altri e non possono accedere alla memoria altrui. Ogni processo viene 
eseguito con le autorizzazione dell'UID dell'utente che lo sta eseguendo. 

\noindent Nel momento della creazione, ad ogni processo sono assegnati tre ID (inizialmente tutti uguali 
all'UID):
\begin{itemize}
    \item \textbf{Effective UID:} determina le autorizzazioni per il processo 
    \item \textbf{Real UID:} determina l'utente che ha avviato il processo 
    \item \textbf{Saved UID:} EUID prima di eventuali modifiche
\end{itemize}

\noindent L'utente \textit{root} può cambiare EUID/RUID/SUID a valori arbitrari; utenti non privilegiati
possono cambiare EUID solo a RUID o SUID

\subsubsection{Unix file access control}
Le modifiche agli ID sono apportate mediante i comandi \textit{setUID} e \textit{setGID}; questa modifica 
permette ai programmi non privilegiati di accedere a risorse generalmente non accessibili.

\noindent Le directory possono aver impostato uno \textit{\textbf{sticky bit}}: specifica che solo il proprietario di un file nella cartella
può apportare una modifica a quel file 

\noindent Il \textit{\textbf{superuser}} è esente dalle consuete restrizioni di controllo degli accessi, ha 
accesso a tutto il sistema.


\subsection{Windows security architecture}
L'architettura di sicurezza di Windows è basata su più entità:
\begin{itemize}
    \item \textbf{\textit{Security Reference Model (SRM):}} componente che in modalità kernel esegue 
    controlli delle autorizzazioni e manipola i privilegi degli utenti
    \item \textbf{\textit{Local Security Authority (LSA):}} risiede in un processo utente, è responsabile 
    dell'applicazione della politica di sicurezza locale, tra cui:
    \begin{itemize}
        \item criteri per le password, come complessità e tempi di scadenza 
        \item politica di controllo $\rightarrow$ specifica quali operazioni su quali oggetti vadano controllate 
        \item impostazioni dei privilegi
    \end{itemize}
    \item \textbf{\textit{Security Account Manager (SAM):}} è un database che archivia i dati degli account e le 
    informazioni di sicurezza su entità locali e gruppi
    \item \textbf{\textit{Active Directory (AD):}} implementa il protocollo LDAP (\textit{Lightweight Directory Access Protocol})
\end{itemize}

\subsubsection{Windows security model}
Windows ha un complesso sistema di controllo dell'accesso; ogni oggetto ha ACL per permettere autorizzazioni 
granulari ad utenti e/o gruppi di utenti.

\subsubsection{Security descriptor}
Ogni oggetto ha un \textit{security descriptor} che contiene:
\begin{itemize}
    \item \textbf{\textit{security identifier} (SID)} per il possessore e il gruppo primario dell'oggetto (SID è 
    associato univocamente ad ogni utente) 
    \item \textbf{\textit{discretionary ACL} (DACL):} diritti di accesso per gli utenti e i gruppi
    \item \textbf{\textit{system ACL} (SACL):} tipi di accesso che generano log
\end{itemize}

\noindent Ad ogni processo viene inoltre associato un insieme di \textbf{token}, che prende il nome di 
\textbf{\textit{security context}}. Nel momento in cui un processo vuole accedere ad un oggetto, presenta 
il suo insieme di token e il sistema controlla se il security context abbia o meno accesso a tale risorsa 
in base al \textit{security descriptor} dell'oggetto.



\chapter{Set-UID}






\chapter{Malware}
\noindent Una definizione informale per malware potrebbe essere quella di \textit{programma malevolo},
solitamente inserito di nascosto in un sistema, che ha lo scopo di compromettere la \textbf{riservatezza}, l'\textbf{integrità} o la \textbf{disponibilità} 
del sistema stesso.

\noindent I malware sono classificati in base a:
\begin{itemize}
    \item \textbf{Propagazione:} software, rete, social engeneering
    \item \textbf{Azioni sui dati colpiti:} corruzione, furto, crittografia
    \item \textbf{Attack kit:} strumenti già pronti per attaccare
    \item \textbf{Attori e/o motivazioni dell'attacco}
\end{itemize}

\section{Differenza tra due tipologie di malware (virus e worm) + esempio}
\noindent Sono stati chiesti questi due ma per sicurezza aggiungo anche gli altri
\subsection{Trojan}
È un programma che ha un effetto evidente e atteso dall'utente, che ha però anche un 
effetto \textbf{nascosto} che viola le politiche di sicurezza e che viene condotto senza l'autorizzazione 
dell'utente

\subsection{Virus}
È un codice che può replicarsi modificando altri file o programmi per inserire codice in 
grado di replicarsi a sua volta; questa \textbf{proprietà di replicazione} è ciò distingue 
i virus dagli altri tipi di malware. Non svolge nessuna azione evidente, ma cerca di rimanere 
nell'ombra.

\noindent La replica richiede un certo tipo di assistenza da parte dell'utente, come ad esempio
cliccare su un allegato.

\noindent Un virus è composto da tre parti:
\begin{itemize}
    \item \textbf{Meccanismo di infezione}
    \item \textbf{Trigger:} evento che determina quando il payload viene attivato
    \item \textbf{Payload:} cosa fa il virus (oltre a diffondersi)
\end{itemize}

\noindent I virus attraversano quattro fasi:
\begin{enumerate}
    \item \textbf{Dormiente:} il virus è inattivo in attesa di essere attivato 
    \item \textbf{Scatenante:} il virus viene attivato 
    \item \textbf{Propagazione:} il virus inserisce una copia di sé stesso in certe parti del sistema; ogni programma 
    infetto conterrà ora un altro virus che entrerà a sua volta in fase di propagazione 
    \item \textbf{Esecutiva:} la funzione viene eseguita
\end{enumerate}

\subsubsection{Vettori di infezione}
I principali vettori di infezione sono:
\begin{itemize}
    \item \textbf{Boot sector} di dispositivi esterni; il codice è inserito nel boot sector e viene 
    eseguito in fase di avvio 
    \item \textbf{Eseguibili}
    \item \textbf{File macro:} il virus si attacca ai documenti per propagarsi 
\end{itemize}

\subsubsection{Esempio noto in letteratura:}
Un esempio di virus può essere considerato il compression virus, che va a comprimere lo spazio occupato da un programma, per inserire un codice malevolo:
così facendo la dimensione di un file è la stessa, andando a baypassare i controlli di un antivirus.

\subsection{Worm}
I worm sono programmi \textit{stand alone} (a differenza dei virus che devono essere attivati 
da un qualche evento) in grado di replicarsi.

\noindent Le fasi di esecuzione sono:
\begin{itemize}
    \item \textbf{Probing:} cerca informazioni sulla macchina 
    \item \textbf{Expoloitation:} sfrutta le informazioni raccolte per trovare vulnerabilità
    \item \textbf{Replicazione}
    \item \textbf{Attacco} (payload)
\end{itemize}

\subsubsection{Esempio noto in litteratura:}
Esempio di worm della famiglia Nimda, che prese di mira i sistemi operativi Microsoft Windows.

\subsection{Drive-by-download}
Sfruttano \textbf{vulnerabilità del browser} per installare codice malevolo ad insaputa dell'utente 
nel momento in cui visita la pagina web dell'attaccante. 

\subsection{Clickjacking}
L'attaccante intercetta un \textit{click} dell'utente per costringerlo a fare delle cose 
contro la sua volontà.

\subsection{Zombie e botnet}
Lo \textit{zombie} è una singola macchina, mentre la \textit{botnet} è un insieme di macchine 
zombie controllate da una singola entità; vengono usate per fare DDoS, phishing, spamming, \dots

\subsection{Rootkit}
È un insieme di programmi installati su un sistema per mantenere l'accesso ad un sistema, ad 
esempio, con privilegi di amministratore, nascondendo le prove della sua presenza e aggirando 
i meccanismi di controllo.

\noindent Permettono di fare attacchi anche con scarse conoscenze tecniche.

\subsection{Scareware}
Software che hanno lo scopo di diffondere shock, ansia e/o la percezione di una minaccia; sono 
un attacco di \textit{social engeneering}.

\subsection{Ransomware}
Software che tiene in ostaggio il sistema per richiedere un riscatto all'utente, spesso tramite
cifratura.

\subsection{Vulnerabilità zero-day}
Si intende un'exploit non ancora nota e che non ha quindi una contromisura.

\subsection{Spear phishing}
Viene \textbf{studiato nel dettaglio il bersaglio}, in modo tale da fare del phishing più mirato 
ed efficace.

\subsection{Spyware}
Malware che raccoglie piccole informazioni alla volta sugli utenti a loro insaputa,
come ad esempio un \textit{keylogger}.

\subsection{APT - Advanced Persistent Threats}
\begin{itemize}
    \item \textit{\textbf{Advanced:}} è un'applicazione con un ampia varietà di tecnologie di intrusione e malware
    \item \textit{\textbf{Persistent:}}
    attacchi per un periodo di tempo prolungato verso il target
    \item \textit{\textbf{Target:}} target selezionati in modo accurato
\end{itemize}

\noindent Le fasi principali di un attacco tramite APT sono:
\begin{itemize}
    \item \textbf{Ricognizione:} si sceglie una vittima e la si studia 
    \item \textbf{Weaponization:} si mette un trojan che permette accesso remoto in un payload consegnabile (email, USB, web)
    \item \textbf{Sfruttamento:} il codice malevolo viene attivato per portare a termine il suo scopo
\end{itemize}



\section{Differenza tra virus metamorfico e polimorfico}
\subsection{Classificazione dei virus}
È possibile classificare i virus in base alle \textbf{tecniche usate per superare i controlli 
di sistema:}
\begin{itemize}
    \item \textbf{Cifratura del virus:} crea una chiave per \textit{"crittografarsi"}; quando viene 
    chiamato un programma infetto, con tale chiave viene decifrato il virus. Per evitare pattern 
    di bit, durante la propagazione la chiave viene cambiata
    \item \textbf{Stealth virus:} si nasconde dal rilevamento da parte dell'antivirus, tramite mutazione 
    o compressione del codice 
    \item \textbf{Polymorphic virus:} durante la replica crea copie che svolgono la stessa funzione 
    ma che hanno pattern di bit diversi 
    \item \textbf{Metamorphic virus:} si riscrive completamente ad ogni iterazione per aumentare la 
    difficoltà di rilevamento
    \item \textbf{Compression virus:} comprimono il file eseguibile in modo che la versione infetta 
    abbia la stessa dimensione di quella originale
\end{itemize} 

\section{Discutere se le seguenti tecniche sono meccanismi di rilevamento utili rispettivamente per i virus polimorfici e metamorfici:}

\subsection{Static pattern matching}
\noindent Utile per \textbf{virus polimorfici} poichè cambiano solo la parte cifrata del loro codice a ogni infezione, ma mantengono invariata la struttura del decryptor,
che può essere riconosciuto con tecniche di pattern matching statico, perché rimane simile o identico tra le varianti.

\noindent Al contrario dei virus metamorfici che modificano completamente il proprio codice a ogni infezione, incluso il decryptor o qualsiasi parte riconoscibile.

\subsection{Pattern matching during emulation}
\noindent Utile per \textbf{virus metamorfici} poichè nonostante essi cambino completamente aspetto a ogni infezione, 
durante l'emulazione (cioè durante l'esecuzione simulata del codice in un ambiente controllato), il virus esegue le stesse azioni fondamentali, indipendentemente dalla sua forma.

\noindent La tecnica di pattern matching during emulation permette quindi di osservare il comportamento reale del codice eseguito (come accessi a file di sistema, chiamate di sistema sospette, o autoriproduzione).

\noindent Al contrario, emulare un virus polimorfico è inefficiente, perché richiede tempo e risorse per ottenere un'informazione che è già ricavabile staticamente.

\subsection{Suspicious behaviour detection}
\noindent Utile per \textbf{virus polimorfici} poichè il loro comportamento rimane molto prevedibile:
\begin{itemize}
    \item Decriptano il corpo
    \item Si copiano in altri file
    \item Cercano persistenza
\end{itemize}

\noindent Per quanto riguarda i virus metamorfici possono cercare di mascherare il loro comportamento,
soprattutto quelli più avanzati possono simulare comportamenti legittimi.

\noindent Questo li rende più difficili da intercettare solo con behaviour detection




\chapter{Autenticazione}

\section{Discutere le problematiche di autenticazione su Web e in dettaglio uno schema challenge-response}
\noindent L'autenticazione in generale, e in particolare quella web, consiste principalmente in un client che fa una richiesta a un server e un server che fornisce una risposta.

\noindent Per fare in modo però che il server non inivii informazioni a client malevoli, che possono attaccare tramite attacchi di spoofing,
fingendosi un client legittimo (o anche fingendosi un server legittimo), oppure con replay attack, ciò inivio di pacchetti già inviati da un client legittimo(tramite 
sniffing sulla rete), vengono introdotte misure di sicurezza più avanzate.

\noindent Client e server condividono informazioni segrete, che possono andare da una password a una chiave di crittografia(secret):
un client che vuole accedere a un servizio web su un server, deve dimostrare di essere chi dichiara di essere. Il server presenta quindi 
una stringa (\textbf{challenge}) e il client, tramite il secret, può fornire la prova di identificazione richiesta e riesce ad accedere (\textbf{response}).

\noindent Questo schema fornisce segretezza, tramite uso di password o chiavi, e anche freschezza, nella misura in cui la challenge viene modificata a ogni richiesta, così
che non si possa sfruttare una risposta già fornita con un replay attack.


\chapter{Attacchi TCP}

\section{ARP spoofing attack, quali sono le possibili conseguenze ed eventuali contromisure}
\noindent Il protocollo ARP (Address Resolution Protocol) si occupa di connettere un indirizzo fisico (MAC address) con un indirizzo logico(IP address). Per farlo ogni nodo all'interno della rete invia dei messaggi in broadcast
per segnalare la sua presenza, così che gli altri nodi possano andare a popolare e/o modificare una tabella interna chiamata \textit{ARP cache table}

\noindent Viene fatta un'assunzione di trust nella LAN, dato che le richieste non vengono tracciate, gli annunci non sono autenticati, le macchine si fidano l'una dell'altra.
In questo modo un possibile attaccante può utilizzare il meccanismo automatico di aggiornamento della ARP cache table (che si aggiorna anche se non ha inviato alcuna richiesta) per fingersi un altro dispositivo.

\noindent \textbf{Conseguenze:} L'attaccante si impone tra due dispositivi permettendogli di intercettare il traffico (sniffing), modificarlo (per esempio per iniettare un malware) o
bloccarlo (DoS).

\noindent \textbf{Contromisure:} Alcune possibili contromisure possono essere:
\begin{itemize}
    \item ARP statici: si configurano manualmente le associazione degli indirizzi IP e MAC, ma non è pratico in reti dinamiche o di grandi dimensioni
    \item Crittografia del traffico: anche se l'attaccante intercetta il traffico, non può leggerne il contenuto.
    \item Strumenti di monitoraggio 
\end{itemize}

\section{Attacco TCP SYN flood e le sue contromisure + SYN-Cookie}
\noindent L'attacco TCP SYN Flood è una forma di attacco DoS (Denial of Service) che mira a sovraccaricare un server esaurendone le risorse disponibili per le connessioni, impedendo così agli utenti legittimi di accedere ai servizi.
L'idea è di sfruttare le vulnerabilità legate alla negoziazione di una comunicazione tra client e server durante il three-way handshake, l'attaccante \textbf{continua a iniviare richieste SYN al server} senza poi rispondere ai SYN/ACK ricevuti in risposta,
il server dovrà quindi attendere andando a saturare il TCB (Trasmission Control Block), impedendo le connessioni legittime.

\noindent \textbf{Contromisure:} ampliare la memoria del TCB in modo che possa ricevere più richieste, ridurre i timer prima che una richiesta SYN venga cancellata dalla memoria o utilizzo dei SYN-Cookie.

\noindent \textit{SYN-Cookie:} Tenica per contrastare l'attacco SYN Flood, l'utilizzo di cookie permette a una sessione di restare attiva anche se la coda SYN è stata saturata da un attacco.
Quando viene attivata una sessione con un three-way handshake, il server risponde a al pacchetto SYN del client con un SYN-ACK più il valore del cookie.
Quando il client risponde con un ACK, il server decodifica il cookie per verificare la validità della richiesta e, solo allora, alloca le risorse necessarie per stabilire la connessione.

\noindent Questo approccio consente al server di gestire un numero elevato di richieste SYN senza esaurire le risorse, poiché non mantiene stato per le connessioni incomplete.

\section{TCP hijacking attack + codice}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/codiceHijacking.png}
\end{figure}

\subsection{TCP hijacking attack ed esempio rispetto al codice}
Il TCP hijacking è un attacco in cui un attaccante prende il controllo di una sessione TCP già avviata tra due host, senza che uno dei due se ne accorga. L'attaccante invia pacchetti spoofati, fingendosi uno degli
endpoint, sfruttando il fatto che TCP si basa su numeri di sequenza e acknowledgment per mantenere la connessione affidabile. L'obiettivo dell'attacco è quello di iniettare dati o comandi nella sessione o interromperla/alterarla.

\noindent Nel nostro scenario ipotetico, l'attaccante intercetta un pacchetto proveniente dal server verso il client in una connessione Telnet. Anche se non conosce l'intero stato della sessione, dal pacchetto osservato può dedurre quale sarà il prossimo numero di sequenza atteso dal server.
A quel punto, può costruire un pacchetto contraffatto, con IP e porta del client e valori di sequenza e acknowledgment coerenti, inserendo nel payload un comando arbitrario da far eseguire alla shell remota. 
Poiché Telnet è un protocollo testuale non cifrato, il comando viene trasmesso come semplice testo ASCII e, se ben formato, sarà interpretato come input valido dal server.

\subsection{Codice}
Questo pacchetto è parte di una connessione Telnet attiva dal server verso il client. L'attaccante ha intercettato questo pacchetto e ora conosce i seguenti dati cruciali:
\begin{itemize}
    \item IP e porte della connessione
    \item Numero di sequenza attuale del server (2737422009)
    \item Numero di acknowledgment del server, che indica quale byte si aspetta dal client (718532383).
    \item La dimensione del payload (24 byte) che è la differenza tra sequence number e next sequence number.
\end{itemize}

\begin{center}
    \textbf{Qual è il pacchetto da da spedire per portare a termine l'attacco?}
\end{center}
\noindent L'attaccante vuole fingere di essere il client che invia dati al server. Per fare ciò, costruisce un pacchetto spoofato con questi campi:
\begin{itemize}
    \item \textbf{Src IP:} 10.0.2.68 (IP del client)
    \item \textbf{Dst IP:} 10.0.2.69 (IP del server)
    \item \textbf{Src Port:} 45634 (porta del client)
    \item \textbf{Dst Port:} 23 (porta standard per Telnet)
    \item \textbf{Sequence number:} 718532383 (numero di sequenza che il server si aspetta dal client)
    \item \textbf{Acknowledgment number:} 2737422033
    \item \textbf{Flags:} PSH,ACK
    \item \textbf{Payload:} ls\textbackslash n (per esempio)
\end{itemize}

\noindent \textit{Note dell'autrice:} 
\begin{itemize}
    \item per trovare Src e Dst IP letteralmente inverti i due indirizzi iniziali
    \item Src Port è quella che prima stava sotto la dicitura Destination Port
    \item il Sequence number è quello che prima si chimava acknowledgment number 
    \item l'acknowledgment number è il nezt sequence number
    \item le flags le copiamo
    \item Importante excursus sul payload: è necessario se vogliamo far eseguire al server un comando, va bene qualsiasi comando Telnet io ho mesos questo a caso
\end{itemize}

\begin{center}
    \textbf{Nel caso si voglia far eseguire un comando al server, come si può procedere?}
\end{center}
\noindent La risposta a sto point è chiaramente il payload!!

\noindent Per far sì che il server esegua un comando (es. in una sessione Telnet), è necessario
inserire nel pacchetto un payload contenente il comando, terminato da un carattere di newline (\textbackslash n), come avverrebbe nella digitazione manuale da parte dell'utente,
ricordandosi che il comando deve avere senso nel contesto della shell remota.






\section{Approcci alla scansione + FTP bounce scan}
\noindent La scansione all'interno di una rete viene eseguita per recuperare informazioni su determinati host o server, l'obiettivo principale è ottenere informazioni
sulle porta utilizzate (TCP/UDP), ciò quali porte sono aperte e in ascolto su determinati nodi, oltre che determinare quale sistema operativo è presente e se esistono sistemi di filtraggio o 
firewall in una determinata rete.

\noindent Lo scanning può essere attivo o passivo:
\begin{itemize}
    \item \textbf{Attivo:} si immette traffico nella rete per recuperare informazioni
    \item \textbf{Passivo:} si fa sniffing senza intervenire attivamente
\end{itemize}

\noindent Diversi approcci:
\begin{itemize}
    \item \textbf{Verticale:} host che fa scanning di più target 
    \item \textbf{Orizzontale:} molti host fanno scanning sullo stesso target 
    \item \textbf{Ibrido:} mix tra i due
\end{itemize}

\noindent Infine il target può essere \textbf{singolo}, cioè una macchina, o \textbf{multiplo}, cioè anche una porzione di rete (se non tutta).

\subsection{FTP bounce scan}
L'attacco FTP bounce scan è una tecnica utilizzata per eseguire una scansione delle porte (port scanning) di un host di destinazione indirettamente tramite un server FTP, è una delle tecniche più note di port scanning attraverso terze parti.

\noindent L'attaccante invia al server FTP un comando PORT utilizzando l'indirizzo IP della vittima tramite un pacchetto spoofato.
Se la porta del server è chiusa, quest'ultima risponderà con un pacchetto RST alla richiesta proveniente dal server FTP, mentre verrà eseguita una three-way handshake nel caso in cui la porta fosse aperta.


\subsection{Commentare praticamente il risultato della seguente scansione}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/scansione.png}
\end{figure}
L'attaccante, utilizzando il comando port, riesce a capire che la porta 8080 è aperta (e quindi in ascolto), dato che viene indicato che è possibile trasferire file, mentre la porta 7777 non lo è, dato che non è stata stabilita nessuna connessione.

\subsection{Due tecniche di scansione con TCP}
\subsubsection{TCP Connect Scan}
Questa tecnica tenta di stabilire una connessione TCP completa con la porta target inviando un pacchetto SYN, aspettando la risposta SYN-ACK e completando il handshake con un ACK.

\noindent Se la connessione si stabilisce, la porta è aperta.
Se riceve un pacchetto RST (reset), la porta è chiusa.

\noindent E' semplice da implementare ma rumoroso.

\subsubsection{SYN Scan (Half-open scan)}
Invia un pacchetto SYN al target, ma non completa il handshake. Se riceve un SYN-ACK, invia un pacchetto RST per interrompere la connessione prima che venga completata.

\noindent Se riceve un SYN-ACK la porta è aperta, se riceve RST allora è chiusa.

\noindent Più furiva della connect scan poichè non comporta connessione, ma può essere rilevata da firewall 


\section{Reset Attack}
Un TCP Reset Attack (attacco di reset TCP) è una tecnica usata per interrompere una connessione TCP esistente inviando un pacchetto TCP con il flag RST (Reset) attivo.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/reset.png}
\end{figure}
\noindent In una normale comunicazione TCP, il flag RST viene usato per indicare che qualcosa è andato storto e che la connessione deve essere chiusa immediatamente.
Un attaccante, intercettando o osservando una connessione TCP, invia un pacchetto con flag RST a uno o entrambi i lati della connessione.




\chapter{Attacchi}




\chapter{Scanning}
\section{tecnica IDLE scan illustrando con un esempio le risposte in caso di porta chiusa, aperta o filtrata}
Nel IDLE SCAN abbiamo un \textbf{attaccante}, una \textbf{vittima} e uno \textbf{zombie}, vale a dire un terzo attore che verrà sfruttato dall'attaccante per colpire la vittima indirettamente
e capire se una determinata porta è aperta, oppure no, utilizzando pacchetti TCP.

\noindent L'attaccante manda un pacchetto TCP di tipo SYN\textbackslash ACK allo zombie. Quest'ultimo non si aspetta questo messaggio, perciò risponde con un pacchetto RST e un IPID, vale a dire l'identificativo del frame (es. 12345).

\noindent L'attaccante invia un pacchetto SYN (con la porta da scansionare) spoofato, utilizzando come mittente l'indirizzo IP dello zombie, alla vittima: in questo caso, se la porta è in ascolto, la vittima risponderà 
allo zombie con un pacchetto SYN\textbackslash ACK e un IPID incrementato (es. 12346), a cui lo zombie risponde con un pacchetto RST, in quanto non si aspetta questo genere di comunicazione.

\noindent Infine l'attaccante invia un altro pacchetto di SYN\textbackslash ACK allo zombie, che gli risponde con un RST e un IPID incrementato (es. 12347): confrontando i valori di IPID, l'attaccante capisce che la porta è aperta.

\noindent Se invece la porta fosse chiusa o filtrata, il valore di IPID sarebbe stato incrementato una sola volta, in quanto l'attaccante risponderebbe rispettivamente con un RST o non risponderebbe affatto al pacchetto 
spoofato inviato dall'attaccante, fingendosi lo zombie. 
Con il secondo SYN\textbackslash ACK allo zombie, ci sarebbe quindi solo questo incremento di IPID.

\subsection{contesto della porta 23 della vittima sapendo che l'ultima risposta ottenuta dallo zombie ha id=42380}
L'attaccante vuole capire lo stato della porta TCP 23 del target/vittima usando lo zombie
quindi invia un pacchetto SYN al target con IP sorgente spoofato dello zombie.

\section{ Descrivere sinteticamente i metodi di scansione stealth}
\noindent I meccanismi di scansione stealth sono \textbf{tecniche usate per identificare porte aperte su un sistema senza suscitare allarmi o lasciare tracce evidenti nei log}, cercando di evitare il rilevamento da parte di firewall, IDS (Intrusion Detection System) o sistemi di logging.

\noindent Principi base delle scansioni stealth:
\begin{itemize}
    \item \textbf{Evitare handshake completo:} invece di completare la connessione TCP (che è facilmente loggabile), si inviano pacchetti parziali o particolari per sondare la risposta
    \item \textbf{Minimizzare i pacchetti inviati:} meno traffico significa meno probabilità di essere rilevati
    \item \textbf{Usare pacchetti con flag TCP “particolari”:} per confondere filtri e firewall
\end{itemize}

\section{Differenza tra le tecniche scan stealth e non stealth}
\noindent \textbf{\textit{NON} STEALTH:}
\begin{itemize}
    \item Completano il normale handshake TCP a 3 vie, aprendo una connessione completa con la porta target
    \item Vengono registrate nei log del sistema target 
    \item Facili da rilevare e bloccare, poichè utilizzano pacchetti standard senza trucchi particolari
\end{itemize}

\noindent \textbf{STEALTH:}
\begin{itemize}
    \item Non completano il handshake TCP o inviano pacchetti con flag TCP particolari per evitare di stabilire una connessione completa
    \item Invia meno pacchetti o pacchetti meno “comuni” per confondere firewall e filtri
    \item Ridotta probabilità di essere registrati nei log o rilevati da IDS
\end{itemize}



\chapter{Network Scanning}
\section{Riconoscere e commentare il tipo di scan evidenziato in figura e aggiungere il caso mancante (porta chiusa/aperta)}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/scanEvidenziato.png}
\end{figure}

\noindent Il tipo di attacco è conosciuto come IDLE scan in cui viene utilizzato 
un client intermedio come \textbf{zombie} per rendere complicata risalire all'attaccante. 
La sorgente manda un SYN/ACK allo zombie e aspetta un RST come risposta con IPID. 
Successivamente l'attaccante invia un pacchetto SYN spoofato con IP sorgente del client zombie verso 
la vittima con la porta che vuole scansionare. 
Se la porta è aperta, la vittima risponderà con un SYN/ACK allo zombie. Quest'ultimo non si aspetta un SYN/ACK e risponde 
perciò con un messaggio RST e con un IPID+1. 

\noindent Infine l'attaccante manda nuovamente un pacchetto SYN/ACK al client zombie e, se IPID è aumentato, allora la porta è aperta.

\noindent Manca il caso in cui la porta è chiusa o filtrata: in questo caso IPID non viene aumentato; quindi, l'attaccante capisce che non c'è traffico su quella specifica porta.

\section{Descrivere quali sono le condizioni rilevabili di una porta come risultato di uno scanning e cosa indicano ad un potenziale avversario e 
per ciascuno stato fare un esempio di un tipo di scan che produca quel tipo di stato}

\subsection{condizioni rilevabili}
Una porta può essere:
\begin{itemize}
    \item \textbf{aperta:} quindi un servizio è in ascolto su di essa
    \item \textbf{chiusa:} quindi non c'è nulla in ascolto su di essa 
    \item \textbf{filtrata:} cioè che è presente un firewall che permette l'accesso solo a determinate sorgenti (in quest'ultimo caso non è possibile definire se è aperta o chiusa)
\end{itemize} 

\subsection{esempio per tipo:}
Per testare lo stato di una porta, si può fare un TCP SYN scan che consiste nell'inviare un pacchetto TCP di tipo SYN + la porta da scansionare,
simulando un three-way handshake: se la porta restituisce un pacchetto SYN/ACK, 
allora la porta è aperta, mentre se restituisco un RST, allora è chiusa. Nel caso di una porta filtrata, il comportamento dipende dal firewall.


\section{obiettivi, natura degli approcci al port scanning}
Guardare 5.4
\subsection{risultati possibili per la scansione di una porta}
Una porta può essere in tre stati: aperta, nel senso che c'è un protocollo in ascolto su di essa, pronto per far partire una comunicazione TCP.
chiusa, vale a dire che non è presente nessun protocollo in ascolto e infine filtrata, cioè che è presente un firewall che lascia passare del traffico
su una porta solo a determinate condizioni, come per esempio la provenienza da determinati indirizzi.
In quest'ultimo caso non è possibile capire se un determinato protocollo è in ascolto o meno.

\subsection{Descrivere in dettaglio un approccio allo scan}
IDLE, guardare 7.1




\chapter{Firewall e NIDS}




\end{document} 